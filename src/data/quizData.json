[
    {
        "id": 1,
        "question": "What will be the output of the following?\n\nlet result = false || {} || 20 || null;\nconsole.log(result);",
        "options": {
            "A": "false",
            "B": "{}",
            "C": "20",
            "D": "null"
        },
        "answer": "B",
        "explanation": "The `||` operator returns the first truthy value. `false` is falsy, `{}` is truthy, so `result` becomes `{}`.",
        "difficulty": "easy",
        "category": "logical operators"
    },
    {
        "id": 2,
        "question": "What will be the output of the following?\n\nlet result = false || null || \"\";\nconsole.log(result);",
        "options": {
            "A": "false",
            "B": "null",
            "C": "\"\"",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "The `||` operator returns the first truthy value. Since all values are falsy, it returns the last one which is `\"\"`.",
        "difficulty": "easy",
        "category": "logical operators"
    },
    {
        "id": 3,
        "question": "What will be the output of the following?\n\nlet result = true || [] || {};\nconsole.log(result);",
        "options": {
            "A": "[]",
            "B": "{}",
            "C": "true",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "The `||` operator returns the first truthy value. `true` is truthy, so it is returned immediately without evaluating the rest.",
        "difficulty": "easy",
        "category": "logical operators"
    },
    {
        "id": 4,
        "question": "What will be the output of the following?\n\nconsole.log('ðŸ˜‹' === 'ðŸ˜‹');",
        "options": {
            "A": "true",
            "B": "false",
            "C": "Syntax Error",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "Both emojis are identical string literals. JavaScript compares them by value, and since they are the same, the result is `true`.",
        "difficulty": "easy",
        "category": "equality comparison"
    },
    {
        "id": 6,
        "question": "What will be the output of the following?\n\nlet data = \"false\";\nconsole.log(!!data);",
        "options": {
            "A": "false",
            "B": "true",
            "C": "undefined",
            "D": "\"false\""
        },
        "answer": "B",
        "explanation": "The string \"false\" is a non-empty string, so it is truthy. `!!data` converts it to boolean: first `!data` becomes false, then `!false` becomes true.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 7,
        "question": "What will be the output of the following?\n\nconsole.log(+true);\nconsole.log(typeof +true);",
        "options": {
            "A": "true, boolean",
            "B": "1, string",
            "C": "1, number",
            "D": "NaN, number"
        },
        "answer": "C",
        "explanation": "`+true` converts the boolean `true` to a number, which is `1`. The type of `1` is `number`.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 8,
        "question": "What will be the output of the following?\n\nconsole.log(!\"neel\");\nconsole.log(typeof(\"neel\"));",
        "options": {
            "A": "true, string",
            "B": "false, string",
            "C": "false, object",
            "D": "true, object"
        },
        "answer": "B",
        "explanation": "The string \"neel\" is a non-empty string, so it's truthy. `!\"neel\"` becomes `false`. The type of any string literal is `string`.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 9,
        "question": "What will be the output of the following?\n\nconsole.log(false == []);\nconsole.log(false == ![]);\nconsole.log(\"\" == []);",
        "options": {
            "A": "true, true, false",
            "B": "true, false, true",
            "C": "false, false, false",
            "D": "false, true, false"
        },
        "answer": "B",
        "explanation": "`false == []` is true because both convert to 0. `false == ![]` is false because `![]` is false, so `false == false`. `\"\" == []` is true because both become \"\" and then 0, so `0 == 0`.",
        "difficulty": "medium",
        "category": "type coercion"
    },
    {
        "id": 10,
        "question": "What will be the output of the following?\n\nconsole.log([] === []);\nconsole.log({} === {});\nconsole.log([] == []);\nconsole.log({} == {});",
        "options": {
            "A": "true, true, true, true",
            "B": "false, false, true, true",
            "C": "false, false, false, false",
            "D": "true, false, true, false"
        },
        "answer": "C",
        "explanation": "In JavaScript, objects and arrays are compared by reference, not by value. Each `[]` and `{}` is a new object, so comparing them with `==` or `===` returns `false`.",
        "difficulty": "medium",
        "category": "reference comparison"
    },
    {
        "id": 11,
        "question": "What will be the output of the following?\n\nconsole.log(!!null);\nconsole.log(!!1);\nconsole.log(!!\"\");",
        "options": {
            "A": "false, true, false",
            "B": "true, true, false",
            "C": "false, false, true",
            "D": "true, false, false"
        },
        "answer": "A",
        "explanation": "`!!` converts a value to its boolean equivalent. `null` and `\"\"` are falsy, so `!!null` and `!!\"\"` return false. `1` is truthy, so `!!1` returns true.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 12,
        "question": "What will be the output of the following?\n\nconst fname = \"neel\";\nconst age = 23;\nconsole.log(isNaN(fname));\nconsole.log(isNaN(age));",
        "options": {
            "A": "true, true",
            "B": "false, false",
            "C": "true, false",
            "D": "false, true"
        },
        "answer": "C",
        "explanation": "`isNaN(\"neel\")` is true because the string cannot be converted to a number. `isNaN(23)` is false because it's a valid number.",
        "difficulty": "easy",
        "category": "type checking"
    },
    {
        "id": 13,
        "question": "What will be the output of the following?\n\nconsole.log(+false);\nconsole.log(+true);\nconsole.log(!\"Neel\");",
        "options": {
            "A": "0, 1, true",
            "B": "0, 1, false",
            "C": "false, true, false",
            "D": "NaN, 1, false"
        },
        "answer": "B",
        "explanation": "`+false` is `0`, `+true` is `1`. `!\"Neel\"` is `false` because non-empty strings are truthy and the `!` operator negates that.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 14,
        "question": "What will be the output of the following?\n\nconsole.log(null == 0);\nconsole.log(null > 0);\nconsole.log(null >= 0);",
        "options": {
            "A": "false, false, true",
            "B": "false, true, false",
            "C": "true, true, true",
            "D": "false, false, false"
        },
        "answer": "A",
        "explanation": "`null == 0` is false because loose equality does not convert `null` to a number. `null > 0` is false, but `null >= 0` is true because `null` gets converted to `0` for relational comparison.",
        "difficulty": "medium",
        "category": "type coercion"
    },
    {
        "id": 15,
        "question": "What will be the output of the following?\n\nconsole.log(-1 == 1);\nconsole.log(-1 === 1);\nconsole.log(-0 == 0);\nconsole.log(-0 === 0);\nconsole.log(Object.is(-0, 0));",
        "options": {
            "A": "false, false, true, true, false",
            "B": "true, true, true, true, true",
            "C": "false, false, false, false, false",
            "D": "false, false, true, true, true"
        },
        "answer": "A",
        "explanation": "`-1 == 1` and `-1 === 1` are false due to different values. `-0 == 0` and `-0 === 0` are both true in JavaScript. However, `Object.is(-0, 0)` returns false because it distinguishes `-0` from `0`.",
        "difficulty": "medium",
        "category": "equality comparison"
    },
    {
        "id": 16,
        "question": "What will be the output of the following?\n\nconst fname = \"Neel samel\";\nconsole.log(!typeof fname === \"object\");\nconsole.log(!typeof fname === \"string\");",
        "options": {
            "A": "true, true",
            "B": "false, false",
            "C": "false, true",
            "D": "true, false"
        },
        "answer": "B",
        "explanation": "The `!typeof fname` part evaluates first due to operator precedence. `typeof fname` returns `'string'`, so `!typeof fname` becomes `false`. Then you get `false === \"object\"` and `false === \"string\"`, both of which are false.",
        "difficulty": "medium",
        "category": "operator precedence"
    },
    {
        "id": 17,
        "question": "What will be the output of the following?\n\nlet a = \"neeel\";\nlet b = `neeel`;\nconsole.log(a === b);",
        "options": {
            "A": "true",
            "B": "false",
            "C": "undefined",
            "D": "TypeError"
        },
        "answer": "A",
        "explanation": "Both `a` and `b` are strings with the same value. Template literals (backticks) and double quotes both produce string primitives, so strict equality returns true.",
        "difficulty": "easy",
        "category": "template literals"
    },
    {
        "id": 18,
        "question": "What will be the output of the following?\n\nconsole.log(typeof Neel);\nconsole.log(typeof new String(\"\"));\nconsole.log(typeof String(\"\"));\nconsole.log(typeof NaN);\nconsole.log(typeof typeof 1);",
        "options": {
            "A": "undefined, object, string, number, string",
            "B": "string, string, string, number, string",
            "C": "undefined, string, object, NaN, number",
            "D": "ReferenceError, object, string, NaN, number"
        },
        "answer": "A",
        "explanation": "`typeof Neel` gives `undefined` (Neel is not declared). `typeof new String(\"\")` returns `object`, `typeof String(\"\")` returns `string`, `typeof NaN` is `number`, and `typeof typeof 1` is `string` because `typeof 1` returns `'number'` which is a string.",
        "difficulty": "hard",
        "category": "typeof operator"
    },
    {
        "id": 19,
        "question": "What will be the output of the following?\n\nlet str = new String(\"JS\");\nconsole.log(str === \"JS\");\nconsole.log(str == \"JS\");",
        "options": {
            "A": "true, true",
            "B": "false, true",
            "C": "false, false",
            "D": "true, false"
        },
        "answer": "B",
        "explanation": "`new String(\"JS\")` creates a String object. Using `===` compares object with primitive, which is false. `==` converts the object to its primitive (`\"JS\"`) and compares, so it's true.",
        "difficulty": "medium",
        "category": "object vs primitive"
    },
    {
        "id": 20,
        "question": "What will be the output of the following?\n\nlet str = \"Neel\";\nconsole.log(JSON.stringify(str));\nconsole.log(JSON.stringify(str) === str);",
        "options": {
            "A": "\"Neel\", true",
            "B": "Neel, false",
            "C": "\"Neel\", false",
            "D": "Neel, true"
        },
        "answer": "C",
        "explanation": "`JSON.stringify(str)` converts the string into a JSON-safe string by wrapping it in double quotes (i.e., returns `\"Neel\"`). So `\"Neel\" === Neel` returns false because one has quotes and the other doesn't.",
        "difficulty": "medium",
        "category": "JSON and type coercion"
    },
    {
        "id": 21,
        "question": "What will be the output of the following?\n\nlet a = [];\nlet b = a;\nconsole.log(a == b);\nconsole.log(a === b);",
        "options": {
            "A": "false, false",
            "B": "true, false",
            "C": "true, true",
            "D": "false, true"
        },
        "answer": "C",
        "explanation": "Both `a` and `b` refer to the same array object in memory. So both `==` and `===` return true because they compare the same reference.",
        "difficulty": "easy",
        "category": "reference vs value"
    },
    {
        "id": 22,
        "question": "What will be the output of the following?\n\nlet a = [20];\nlet b = [20];\nconsole.log(a[0] == b[0]);\nconsole.log(a[0] === b[0]);",
        "options": {
            "A": "true, true",
            "B": "false, false",
            "C": "true, false",
            "D": "false, true"
        },
        "answer": "A",
        "explanation": "Both `a[0]` and `b[0]` are primitive numbers (`20`). Primitive values are compared by value, so both `==` and `===` return true.",
        "difficulty": "easy",
        "category": "primitive comparison"
    },
    {
        "id": 23,
        "question": "What will be the output of the following?\n\nlet a = 3;\nlet b = new Number(3);\nconsole.log(a == b);\nconsole.log(a === b);",
        "options": {
            "A": "true, true",
            "B": "false, false",
            "C": "true, false",
            "D": "false, true"
        },
        "answer": "C",
        "explanation": "`a == b` is true because loose equality converts the object `b` to its primitive value before comparing. `a === b` is false because one is a number and the other is a Number object.",
        "difficulty": "medium",
        "category": "type coercion"
    },
    {
        "id": 24,
        "question": "How can we check if a number is even or odd?\n\nlet a = 3;\nlet b = a % 2;\nconsole.log(b);",
        "options": {
            "A": "0 (Even)",
            "B": "1 (Odd)",
            "C": "3 (Original Number)",
            "D": "2 (Invalid)"
        },
        "answer": "B",
        "explanation": "`a % 2` gives the remainder when `a` is divided by 2. If the remainder is 1, itâ€™s an odd number. If 0, it's even. Since 3 % 2 is 1, the number is odd.",
        "difficulty": "easy",
        "category": "arithmetic"
    },
    {
        "id": 25,
        "question": "What will be the output of the following?\n\nconsole.log(3 * 3);\nconsole.log(3 ** 3);\nconsole.log(3 *** 3);",
        "options": {
            "A": "9, 27, 81",
            "B": "9, 27, SyntaxError",
            "C": "9, 27, NaN",
            "D": "SyntaxError, SyntaxError, SyntaxError"
        },
        "answer": "B",
        "explanation": "`3 * 3` returns 9 (multiplication). `3 ** 3` returns 27 (exponentiation). `3 *** 3` is not valid syntax and throws a SyntaxError.",
        "difficulty": "medium",
        "category": "operator precedence"
    },
    {
        "id": 26,
        "question": "What will be the output of the following?\n\nlet a = 22;\nlet A = 23;\nconsole.log(a);",
        "options": {
            "A": "22",
            "B": "23",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "JavaScript is case-sensitive, so `a` and `A` are treated as two different variables. `console.log(a)` prints the value of `a`, which is 22.",
        "difficulty": "easy",
        "category": "variables / case sensitivity"
    },
    {
        "id": 27,
        "question": "What will be the output of the following?\n\nlet a = 23;\nlet b = 22;\nconsole.log(--a === b);",
        "options": {
            "A": "true",
            "B": "false",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "`--a` decrements `a` before comparison, making `a = 22`. Since `b` is also 22, `--a === b` evaluates to `true`.",
        "difficulty": "easy",
        "category": "operators / comparison"
    },
    {
        "id": 28,
        "question": "What will be the output of the following?\n\nlet a = 1;\nlet b = 1;\nlet c = 2;\nconsole.log(a === b === --c);",
        "options": {
            "A": "true",
            "B": "false",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "`a === b` returns `true`. Then `true === --c` becomes `true === 1`, which is false because of strict type mismatch (`boolean === number`).",
        "difficulty": "medium",
        "category": "comparison / evaluation order"
    },
    {
        "id": 29,
        "question": "What will be the output of the following?\n\nconsole.log(a);",
        "options": {
            "A": "undefined",
            "B": "null",
            "C": "ReferenceError",
            "D": "NaN"
        },
        "answer": "C",
        "explanation": "`a` is not declared anywhere, so trying to access it throws a `ReferenceError`.",
        "difficulty": "easy",
        "category": "errors / hoisting"
    },
    {
        "id": 30,
        "question": "What will be the output of the following?\n\nvar x;\nvar x = 10;\nconsole.log(x);",
        "options": {
            "A": "undefined",
            "B": "null",
            "C": "10",
            "D": "Error"
        },
        "answer": "C",
        "explanation": "`var` allows redeclaration of variables. So `x` is first declared (undefined) and then assigned 10. `console.log(x)` prints `10`.",
        "difficulty": "easy",
        "category": "variables / var redeclaration"
    },
    {
        "id": 31,
        "question": "What will be the output of the following?\n\nlet x;\nvar x = 10;\nconsole.log(x);",
        "options": {
            "A": "10",
            "B": "undefined",
            "C": "null",
            "D": "SyntaxError"
        },
        "answer": "D",
        "explanation": "`let` does not allow redeclaration with `var` in the same scope. This throws a `SyntaxError` due to duplicate declaration of `x`.",
        "difficulty": "medium",
        "category": "variable declaration / scope"
    },
    {
        "id": 32,
        "question": "What will be the output of the following?\n\nlet a = 23;\nconsole.log(b);",
        "options": {
            "A": "23",
            "B": "undefined",
            "C": "ReferenceError",
            "D": "NaN"
        },
        "answer": "C",
        "explanation": "`b` is not declared anywhere. Accessing an undeclared variable throws a `ReferenceError`.",
        "difficulty": "easy",
        "category": "scope / reference error"
    },
    {
        "id": 33,
        "question": "What will be the output of the following?\n\nfunction sum(a, b) {\n  return a + b;\n}\nconsole.log(sum(2, \"2\"));",
        "options": {
            "A": "4",
            "B": "22",
            "C": "undefined",
            "D": "NaN"
        },
        "answer": "B",
        "explanation": "When adding a number (`2`) and a string (`\"2\"`), JavaScript performs string concatenation. So `2 + \"2\"` results in the string `'22'`.",
        "difficulty": "easy",
        "category": "type coercion"
    },
    {
        "id": 34,
        "question": "What will be the output of the following?\n\nlet num = 1;\nconsole.log(num++);\nconsole.log(++num);\nconsole.log(num);",
        "options": {
            "A": "2, 3, 3",
            "B": "1, 3, 3",
            "C": "1, 2, 2",
            "D": "2, 2, 3"
        },
        "answer": "B",
        "explanation": "`num++` returns `1` and then increments `num` to `2`. `++num` increments `num` to `3` and returns it. Final `num` is `3`.",
        "difficulty": "medium",
        "category": "increment operators / evaluation order"
    },
    {
        "id": 35,
        "question": "What will be the output of the following?\n\nconst sum = eval(\"10+10*2\");\nconsole.log(sum);",
        "options": {
            "A": "40",
            "B": "30",
            "C": "\"10+10*2\"",
            "D": "20"
        },
        "answer": "B",
        "explanation": "`eval(\"10+10*2\")` evaluates the string as a JavaScript expression. `10 * 2 = 20` then `10 + 20 = 30`.",
        "difficulty": "medium",
        "category": "eval / operator precedence"
    },
    {
        "id": 36,
        "question": "What will be the output of the following?\n\nconst num = 2 + 2 + \"2\";\nconsole.log(typeof num);",
        "options": {
            "A": "number",
            "B": "string",
            "C": "object",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "Evaluation goes left to right. `2 + 2 = 4`, then `4 + \"2\"` results in `'42'`. The final type is `string`.",
        "difficulty": "easy",
        "category": "type-coercion"
    },
    {
        "id": 37,
        "question": "What will be the output of the following?\n\nconsole.log(typeof 2 + 2 + \"2\");",
        "options": {
            "A": "number",
            "B": "string",
            "C": "string22",
            "D": "number22"
        },
        "answer": "D",
        "explanation": "`typeof 2` is `'number'`. Then `'number' + 2` becomes `'number2'`, and `'number2' + \"2\"` becomes `'number22'`.",
        "difficulty": "medium",
        "category": "type-coercion"
    },
    {
        "id": 38,
        "question": "What will be the output of the following?\n\nlet num = 20;\nconsole.log(num + \"20\");\nconsole.log(++num);",
        "options": {
            "A": "2020 and 21",
            "B": "40 and 21",
            "C": "2020 and 20",
            "D": "NaN and 21"
        },
        "answer": "A",
        "explanation": "`num + \"20\"` results in string concatenation, giving `'2020'`. `++num` increments `num` to `21` before logging it.",
        "difficulty": "easy",
        "category": "type-coercion"
    },
    {
        "id": 39,
        "question": "What will be the output of the following?\n\nconsole.log(parseInt(\"108\"));\nconsole.log(parseInt(\"108*33\"));\nconsole.log(parseInt(\"108neel\"));",
        "options": {
            "A": "108, NaN, NaN",
            "B": "108, 108, 108",
            "C": "NaN, 108, 108",
            "D": "108, 0, NaN"
        },
        "answer": "B",
        "explanation": "`parseInt` parses from the start of the string until it encounters a non-digit. So all three cases return `108`.",
        "difficulty": "medium",
        "category": "parsing"
    },
    {
        "id": 40,
        "question": "What will be the output of the following?\n\nconsole.log(4 + \"4\");\nconsole.log(4 + +\"4\");",
        "options": {
            "A": "44 and 8",
            "B": "8 and 44",
            "C": "4 and 4",
            "D": "NaN and NaN"
        },
        "answer": "A",
        "explanation": "`4 + \"4\"` performs string concatenation resulting in `'44'`. `+\"4\"` converts the string to a number, so `4 + 4 = 8`.",
        "difficulty": "medium",
        "category": "type-coercion"
    },
    {
        "id": 41,
        "question": "What will be the output of the following?\n\nconsole.log(99[\"toString\"].length + 1);",
        "options": {
            "A": "0",
            "B": "1",
            "C": "2",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "`toString` refers to the function `Number.prototype.toString`, whose `length` property is 1 (indicating it accepts one argument). Therefore, `1 + 1 = 2`.",
        "difficulty": "medium",
        "category": "typeof / function properties"
    },
    {
        "id": 42,
        "question": "What will be logged from the following code?\n\nconst num1 = Number(3);\nconst num2 = Number();\nconst num3 = Number(undefined);\n\nconsole.log(`num1 = ${num1}`);\nconsole.log(`num2 = ${num2}`);\nconsole.log(`num3 = ${num3}`);",
        "options": {
            "A": "num1 = 3, num2 = 0, num3 = NaN",
            "B": "num1 = 3, num2 = NaN, num3 = 0",
            "C": "num1 = NaN, num2 = 0, num3 = undefined",
            "D": "num1 = 3, num2 = undefined, num3 = 0"
        },
        "answer": "A",
        "explanation": "`Number(3)` gives `3`, `Number()` with no argument gives `0`, and `Number(undefined)` gives `NaN`.",
        "difficulty": "easy",
        "category": "type conversion"
    },
    {
        "id": 43,
        "question": "What will be the output of the following?\n\nconsole.log(0 == \"0\");\nconsole.log(0 == []);\nconsole.log(\"0\" == []);",
        "options": {
            "A": "true, true, true",
            "B": "false, true, false",
            "C": "true, true, false",
            "D": "false, false, true"
        },
        "answer": "C",
        "explanation": "`==` performs type coercion. `0 == \"0\"` is `true` because string is coerced to number. `0 == []` is `true` because `[]` is coerced to `\"\"` then to `0`. But `\"0\" == []` is `false` because `[]` becomes `\"\"`, and `\"0\" != \"\"`.",
        "difficulty": "medium",
        "category": "coercion / equality"
    },
    {
        "id": 44,
        "question": "What will be the output of the following?\n\nconst num1 = 100000;\nconst num2 = 10_0_0_00;\n\nconsole.log(num1 === num2);",
        "options": {
            "A": "true",
            "B": "false",
            "C": "SyntaxError",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "`10_0_0_00` is a valid ES2021 numeric separator syntax and evaluates to 100000. So both values are strictly equal.",
        "difficulty": "medium",
        "category": "numeric separators / strict equality"
    },
    {
        "id": 45,
        "question": "What will be logged?\n\nlet age = \"22\";\nlet validage = '22';\n\nage += 1;\nvalidage++;\n\nconsole.log(age);\nconsole.log(validage);",
        "options": {
            "A": "\"221\" and 22",
            "B": "23 and 23",
            "C": "\"23\" and 23",
            "D": "\"221\" and 23"
        },
        "answer": "D",
        "explanation": "`age += 1` performs string concatenation, resulting in `'221'`. `validage++` converts the string `'22'` to number, then increments to `23`.",
        "difficulty": "easy",
        "category": "type coercion / increment"
    },
    {
        "id": 46,
        "question": "What will be the output of the following?\n\nlet num = 2;\nlet foo = !--num;\nlet boo = !--num;\n\nconsole.log(foo);\nconsole.log(boo);",
        "options": {
            "A": "false and true",
            "B": "true and false",
            "C": "false and false",
            "D": "true and true"
        },
        "answer": "A",
        "explanation": "`--num` decrements first, so num becomes 1 and then 0. `!1` is `false`, `!0` is `true`. So outputs are `false` and `true`.",
        "category": "unary & logical operator",
        "difficulty": "medium"
    },
    {
        "id": 47,
        "question": "What is the type of the value returned from the following function?\n\nfunction chk(){\n    return (() => 1)();\n}\n\nconsole.log(typeof chk());",
        "options": {
            "A": "function",
            "B": "undefined",
            "C": "number",
            "D": "object"
        },
        "answer": "C",
        "explanation": "An arrow function that returns `1` is immediately invoked. The return value is `1`, whose type is `number`.",
        "category": "arrow function",
        "difficulty": "medium"
    },
    {
        "id": 48,
        "question": "What will be the output of the following?\n\nfunction chk(){\n    return (() => 1);\n}\nconsole.log(typeof chk);",
        "options": {
            "A": "number",
            "B": "function",
            "C": "object",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "`chk` is a regular function that returns an arrow function, but `chk` itself is still a function. `typeof chk` returns `'function'`.",
        "category": "function & typeof",
        "difficulty": "easy"
    },
    {
        "id": 49,
        "question": "What will be logged?\n\nfunction add(num) {\n    let n = Number(num);\n    n = n + 1;\n    console.log(n);\n}\nadd(2);",
        "options": {
            "A": "2",
            "B": "3",
            "C": "NaN",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "`Number(2)` returns `2`, then adding `1` gives `3`. The function logs `3`.",
        "category": "conversion",
        "difficulty": "easy"
    },
    {
        "id": 50,
        "question": "What will be the output?\n\nfunction sum(n1, n2 = n1) {\n  console.log(n1 + n2);\n}\n\nsum(10);",
        "options": {
            "A": "10",
            "B": "20",
            "C": "NaN",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "`n2` defaults to the value of `n1` if not provided. So `n1 = 10`, `n2 = 10`, and the output is `20`.",
        "category": "default parameters",
        "difficulty": "medium"
    },
    {
        "id": 51,
        "question": "What will be the output of the following?\n\nfunction sum(){\n    return 2 + 2;\n}\nfunction sq(){\n    return 4 * 4;\n}\nlet a = (sum(), sq());\nconsole.log(a);",
        "options": {
            "A": "4",
            "B": "16",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The comma operator evaluates multiple expressions and returns the result of the last one. So `sum()` is evaluated but its result is discarded. `sq()` returns `16`, which is assigned to `a`.",
        "difficulty": "medium",
        "category": "comma operator"
    },
    {
        "id": 52,
        "question": "let name = 'neel';\nname[0] = 'N';\nconsole.log(name);",
        "options": {
            "A": "'Neel'",
            "B": "'neel'",
            "C": "['n', 'e', 'e', 'l']",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Strings are immutable in JavaScript. Modifying `name[0]` has no effect.",
        "difficulty": "easy",
        "category": "string immutability"
    },
    {
        "id": 53,
        "question": "var age = 23;\nconsole.log(window.age);",
        "options": {
            "A": "undefined",
            "B": "null",
            "C": "23",
            "D": "Error"
        },
        "answer": "C",
        "explanation": "`var` declares variables in the global scope (attached to `window` in browsers), so `window.age` is 23.",
        "difficulty": "medium",
        "category": "global scope"
    },
    {
        "id": 54,
        "question": "let for = 'neel';",
        "options": {
            "A": "'neel'",
            "B": "undefined",
            "C": "Error",
            "D": "null"
        },
        "answer": "C",
        "explanation": "`for` is a reserved keyword in JavaScript and cannot be used as a variable name.",
        "difficulty": "easy",
        "category": "reserved keywords"
    },
    {
        "id": 55,
        "question": "const a = 1 + undefined;\nconst b = 1 + typeof C;\nconsole.log(a);\nconsole.log(b);",
        "options": {
            "A": "NaN, '1undefined'",
            "B": "'1undefined', NaN",
            "C": "NaN, NaN",
            "D": "'undefined', NaN"
        },
        "answer": "A",
        "explanation": "`1 + undefined` results in NaN. `typeof C` returns 'undefined', so `1 + 'undefined'` becomes the string '1undefined'.",
        "difficulty": "medium",
        "category": "type coercion"
    },
    {
        "id": 56,
        "question": "let a = 2+2+\"2\";\nconsole.log(typeof a);",
        "options": {
            "A": "number",
            "B": "string",
            "C": "object",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "2 + 2 = 4, then 4 + '2' results in the string '42'. So typeof a is 'string'.",
        "category": "type coercion",
        "difficulty": "easy"
    },
    {
        "id": 57,
        "question": "console.log(typeof 2+2+\"2\");",
        "options": {
            "A": "number22",
            "B": "string",
            "C": "undefined",
            "D": "number22"
        },
        "answer": "D",
        "explanation": "`typeof 2` is 'number', so 'number' + 2 = 'number2', then + '2' = 'number22'.",
        "category": "operator precedence + coercion",
        "difficulty": "medium"
    },
    {
        "id": 58,
        "question": "const sum = eval(\"10+10*2\");\nconsole.log(sum);",
        "options": {
            "A": "40",
            "B": "30",
            "C": "NaN",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "The expression evaluates to 10 + (10 * 2) = 30. `eval` executes the string as JS code.",
        "category": "eval + operator precedence",
        "difficulty": "easy"
    },
    {
        "id": 59,
        "question": "let num = 1;\nconsole.log(num++);\nconsole.log(++num);\nconsole.log(num);",
        "options": {
            "A": "1 2 2",
            "B": "1 3 3",
            "C": "2 2 3",
            "D": "1 2 3"
        },
        "answer": "B",
        "explanation": "`num++` logs 1 and then increments to 2. `++num` increments to 3 and logs 3. Final log is 3.",
        "category": "increment operators",
        "difficulty": "medium"
    },
    {
        "id": 60,
        "question": "function sum(a,b){ return a+b }\nconsole.log(sum(2,\"2\"));",
        "options": {
            "A": "4",
            "B": "NaN",
            "C": "22",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "When adding a number and a string, JavaScript coerces the number to a string and concatenates.",
        "category": "type coercion",
        "difficulty": "easy"
    },
    {
        "id": 61,
        "question": "What will be the output?\n\nconst num = [1,2,3]\nnum[5] = 5\nconsole.log(num)",
        "options": {
            "A": "[1, 2, 3, empty Ã— 2, 5]",
            "B": "[1, 2, 3, undefined, undefined, 5]",
            "C": "[1, 2, 3, null, null, 5]",
            "D": "[1, 2, 3, 5]"
        },
        "answer": "A",
        "explanation": "Assigning a value to an index beyond the current length creates empty slots. So indices 3 and 4 are empty.",
        "category": "array holes",
        "difficulty": "medium"
    },
    {
        "id": 62,
        "question": "What will be the output?\n\nconst arr = [1,2,3,4]\nconsole.log(arr[5])",
        "options": {
            "A": "undefined",
            "B": "null",
            "C": "0",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "Index 5 is out of bounds and not defined, so JavaScript returns undefined.",
        "category": "array access",
        "difficulty": "easy"
    },
    {
        "id": 63,
        "question": "What will be the output?\n\ndelete data[1]\nconsole.log(data)\n\nlet data = [\"neel\",\"ashok\",\"samel\"]",
        "options": {
            "A": "[\"neel\", null, \"samel\"]",
            "B": "[\"neel\", undefined, \"samel\"]",
            "C": "[\"neel\", empty, \"samel\"]",
            "D": "[\"neel\", false, \"samel\"]"
        },
        "answer": "C",
        "explanation": "The `delete` operator removes the element but leaves an empty slot.",
        "category": "array holes + delete",
        "difficulty": "medium"
    },
    {
        "id": 64,
        "question": "What will be the output?\n\nconst array = [{Name:\"Neel\"},2,3]\ndelete array[0]\nconsole.log(array.length, array)",
        "options": {
            "A": "2, [empty, 2, 3]",
            "B": "3, [undefined, 2, 3]",
            "C": "3, [empty, 2, 3]",
            "D": "undefined, [2, 3]"
        },
        "answer": "C",
        "explanation": "The length remains 3 because delete only empties the slot, it doesnâ€™t reduce the array size.",
        "category": "delete operator in array",
        "difficulty": "medium"
    },
    {
        "id": 65,
        "question": "What will be the output?\n\nconst arr = [,,,]\nconsole.log(arr.length)",
        "options": {
            "A": "0",
            "B": "1",
            "C": "3",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "Each comma creates an empty slot; 3 commas mean array has length 3.",
        "category": "array holes",
        "difficulty": "easy"
    },
    {
        "id": 66,
        "question": "What will be the output?\n\nconsole.log([...[...\"...\"].length])",
        "options": {
            "A": "3",
            "B": "1",
            "C": "undefined",
            "D": "Syntax Error"
        },
        "answer": "A",
        "explanation": "\"...\" is a string of 3 characters, spreading it creates 3 dots, then spreading again results in 3 elements.",
        "category": "spread operator, strings, destructuring",
        "difficulty": "medium"
    },
    {
        "id": 67,
        "question": "What will be the output?\n\nlet newlist = [2,3].push(4)\nconsole.log(newlist.push(5))",
        "options": {
            "A": "Error",
            "B": "3",
            "C": "4",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "push returns a number (new length). `newlist` is a number, so calling `.push()` on it throws an error.",
        "category": "array methods, type coercion",
        "difficulty": "medium"
    },
    {
        "id": 68,
        "question": "What will be the output?\n\ndata1.reverse()\ndata2.toReversed()\nconsole.log(data1)\nconsole.log(data2)",
        "options": {
            "A": "[\"C\",\"B\",\"A\"] and [\"X\",\"Y\",\"Z\"]",
            "B": "[\"A\",\"B\",\"C\"] and [\"X\",\"Y\",\"Z\"]",
            "C": "[\"A\",\"B\",\"C\"] and [\"Z\",\"Y\",\"X\"]",
            "D": "[\"A\",\"B\",\"C\"] and [\"X\",\"Y\",\"Z\"]"
        },
        "answer": "C",
        "explanation": "`reverse()` mutates the original array. `toReversed()` returns a reversed copy (added in ES2023).",
        "category": "array methods, immutability, ES2023",
        "difficulty": "medium"
    },
    {
        "id": 69,
        "question": "What will be the output?\n\ndata1.sort()\ndata2.toSorted()\nconsole.log(data1)\nconsole.log(data2)",
        "options": {
            "A": "[\"A\",\"B\",\"C\"] and [\"Z\",\"Y\",\"X\"]",
            "B": "[\"A\",\"B\",\"C\"] and [\"X\",\"Y\",\"Z\"]",
            "C": "[\"Z\",\"Y\",\"X\"] and [\"A\",\"B\",\"C\"]",
            "D": "None of the above"
        },
        "answer": "B",
        "explanation": "`sort()` mutates data1. `toSorted()` creates a sorted clone (added in ES2023).",
        "category": "array methods, immutability, ES2023",
        "difficulty": "medium"
    },
    {
        "id": 70,
        "question": "What will be the output?\n\nconst score = [12,43,56,122]\nscore.sort()\nconsole.log(score)",
        "options": {
            "A": "[122, 12, 43, 56]",
            "B": "[12, 122, 43, 56]",
            "C": "[12, 43, 56, 122]",
            "D": "[122, 56, 43, 12]"
        },
        "answer": "B",
        "explanation": "`sort()` converts numbers to strings and sorts lexicographically. '122' comes before '43'.",
        "category": "array methods, sort, coercion",
        "difficulty": "easy"
    },
    {
        "id": 71,
        "question": "What will be the output of the following?\n\nconst num = [1, 2, 3];\nnum[5] = num;\nconsole.log(num);",
        "options": {
            "A": "[1, 2, 3, empty Ã— 2, Array(6)]",
            "B": "[1, 2, 3, undefined, undefined, [1,2,3]]",
            "C": "[1, 2, 3, null, null, Array]",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "The array is sparse. Index 3 and 4 are left unassigned, so they are empty. At index 5, we assign the array itself, creating a circular reference. The output shows as `[1, 2, 3, empty Ã— 2, Array(6)]`.",
        "category": "arrays, sparse arrays, references",
        "difficulty": "medium"
    },
    {
        "id": 72,
        "question": "What does this return?\n\nlet a = [1,2,3,4];\nlet b = {name: 'neel'};\nconsole.log(...a);",
        "options": {
            "A": "1 2 3 4",
            "B": "[1,2,3,4]",
            "C": "{name: 'neel'}",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "The spread operator `...a` spreads array elements as individual arguments. Since `console.log` can accept multiple arguments, it prints `1 2 3 4`. The object `b` is unrelated.",
        "category": "spread operator, arrays",
        "difficulty": "easy"
    },
    {
        "id": 73,
        "question": "What will be logged?\n\nconsole.log([[[[]]]]);",
        "options": {
            "A": "[]",
            "B": "[[[[]]]]",
            "C": "[[[Array(0)]]]",
            "D": "[[[]]]"
        },
        "answer": "B",
        "explanation": "This is a 3-level nested array where the innermost array is empty. JavaScript displays it exactly as `[[[[]]]]`.",
        "category": "arrays, nesting",
        "difficulty": "easy"
    },
    {
        "id": 74,
        "question": "What is the result of this check?\n\nlet num = [1,2,3];\nconsole.log(2 in num);\nconsole.log(3 in num);",
        "options": {
            "A": "true false",
            "B": "false false",
            "C": "true true",
            "D": "false true"
        },
        "answer": "A",
        "explanation": "`2 in num` is true because index 2 exists. `3 in num` is false because index 3 has not been assigned.",
        "category": "arrays, in operator, indexing",
        "difficulty": "easy"
    },
    {
        "id": 75,
        "question": "What is the output?\n\nlet a = [].every(() => true);\nlet b = [].every(() => false);\nconsole.log(a);\nconsole.log(b);",
        "options": {
            "A": "true false",
            "B": "false true",
            "C": "false false",
            "D": "true true"
        },
        "answer": "D",
        "explanation": "The `.every()` method on an empty array returns true by definition (vacuous truth), regardless of the condition.",
        "category": "array methods, every, logic",
        "difficulty": "medium"
    },
    {
        "id": 76,
        "question": "What will be the output?\n\nconst a = new Set([1, 2, 3, 4, 1, 2, 3, 4]);\nconsole.log(a);",
        "options": {
            "A": "Set(4) {1, 2, 3, 4}",
            "B": "Set(8) {1, 2, 3, 4, 1, 2, 3, 4}",
            "C": "[1, 2, 3, 4]",
            "D": "Set(4) {1, 2, 3, 4, undefined}"
        },
        "answer": "A",
        "explanation": "A `Set` automatically removes duplicate values. Hence only unique values {1, 2, 3, 4} are stored.",
        "difficulty": "easy",
        "category": "set"
    },
    {
        "id": 77,
        "question": "What does the following code print?\n\nconst set = new Set([1, 2, 3, 4, 5]);\nconsole.log(set.has(1));\nconsole.log(set.has(\"1\"));",
        "options": {
            "A": "true true",
            "B": "true false",
            "C": "false false",
            "D": "false true"
        },
        "answer": "B",
        "explanation": "`set.has(1)` is true because 1 is in the set. `set.has(\"1\")` is false because string \"1\" is not the same as number 1 (Set uses strict equality).",
        "difficulty": "medium",
        "category": "set"
    },
    {
        "id": 78,
        "question": "What will be the output?\n\nconst cnt = [\"neel\", \"ashok\", \"samel\"];\ncnt.slice(0, 1);\nconsole.log(cnt);",
        "options": {
            "A": "[\"neel\"]",
            "B": "[\"neel\", \"ashok\", \"samel\"]",
            "C": "[\"ashok\", \"samel\"]",
            "D": "[\"neel\", \"ashok\"]"
        },
        "answer": "B",
        "explanation": "`slice()` returns a shallow copy and does not modify the original array. So `cnt` remains unchanged.",
        "difficulty": "easy",
        "category": "array-methods"
    },
    {
        "id": 79,
        "question": "What will be the result?\n\nconst score = [12, 43, 56, 122];\nscore.sort();\nconsole.log(score);",
        "options": {
            "A": "[12, 43, 56, 122]",
            "B": "[122, 12, 43, 56]",
            "C": "[12, 122, 43, 56]",
            "D": "[122, 56, 43, 12]"
        },
        "answer": "C",
        "explanation": "`sort()` converts elements to strings and sorts them lexicographically. '122' comes before '43'.",
        "difficulty": "medium",
        "category": "array-methods"
    },
    {
        "id": 80,
        "question": "What is the result?\n\nconst arr = [,,,];\nconsole.log(arr.length);",
        "options": {
            "A": "0",
            "B": "2",
            "C": "3",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "The array has 3 empty slots (sparse array). Empty slots still count toward the `length` property.",
        "difficulty": "medium",
        "category": "arrays"
    },
    {
        "id": 76,
        "question": "What will be the output?\n\nconst a = new Set([1, 2, 3, 4, 1, 2, 3, 4]);\nconsole.log(a);",
        "options": {
            "A": "Set(4) {1, 2, 3, 4}",
            "B": "Set(8) {1, 2, 3, 4, 1, 2, 3, 4}",
            "C": "[1, 2, 3, 4]",
            "D": "Set(4) {1, 2, 3, 4, undefined}"
        },
        "answer": "A",
        "explanation": "A `Set` automatically removes duplicate values. Hence only unique values {1, 2, 3, 4} are stored.",
        "difficulty": "easy",
        "category": "Set"
    },
    {
        "id": 77,
        "question": "What does the following code print?\n\nconst set = new Set([1, 2, 3, 4, 5]);\nconsole.log(set.has(1));\nconsole.log(set.has(\"1\"));",
        "options": {
            "A": "true true",
            "B": "true false",
            "C": "false false",
            "D": "false true"
        },
        "answer": "B",
        "explanation": "`set.has(1)` is true because 1 is in the set. `set.has(\"1\")` is false because string \"1\" is not the same as number 1 (Set uses strict equality).",
        "difficulty": "medium",
        "category": "Set"
    },
    {
        "id": 78,
        "question": "What will be the output?\n\nconst cnt = [\"neel\", \"ashok\", \"samel\"];\ncnt.slice(0, 1);\nconsole.log(cnt);",
        "options": {
            "A": "[\"neel\"]",
            "B": "[\"neel\", \"ashok\", \"samel\"]",
            "C": "[\"ashok\", \"samel\"]",
            "D": "[\"neel\", \"ashok\"]"
        },
        "answer": "B",
        "explanation": "`slice()` returns a shallow copy and does not modify the original array. So `cnt` remains unchanged.",
        "difficulty": "easy",
        "category": "Array"
    },
    {
        "id": 79,
        "question": "What will be the result?\n\nconst score = [12, 43, 56, 122];\nscore.sort();\nconsole.log(score);",
        "options": {
            "A": "[12, 43, 56, 122]",
            "B": "[122, 12, 43, 56]",
            "C": "[12, 122, 43, 56]",
            "D": "[122, 56, 43, 12]"
        },
        "answer": "C",
        "explanation": "`sort()` converts elements to strings and sorts them lexicographically. '122' comes before '43'.",
        "difficulty": "medium",
        "category": "Array"
    },
    {
        "id": 80,
        "question": "What is the result?\n\nconst arr = [,,,];\nconsole.log(arr.length);",
        "options": {
            "A": "0",
            "B": "2",
            "C": "3",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "The array has 3 empty slots (sparse array). Empty slots still count toward the `length` property.",
        "difficulty": "medium",
        "category": "Array"
    },
    {
        "id": 81,
        "question": "What will be the output?\n\n```js\nlet user = { name: \"Neel samel\" };\nconst userList = [user];\nuser = null;\nconsole.log(userList);\nconsole.log(user);\n```",
        "options": {
            "A": "[null], null",
            "B": "[{ name: 'Neel samel' }], null",
            "C": "[undefined], undefined",
            "D": "null, [{ name: 'Neel samel' }]"
        },
        "answer": "B",
        "explanation": "Even though `user` is set to null, the `userList` array still holds a reference to the original object. Hence, the first log prints the object, and the second prints `null`.",
        "difficulty": "medium",
        "category": "Reference vs Value"
    },
    {
        "id": 82,
        "question": "What will happen when this function is invoked?\n\n```js\nfunction getItems(list, ...args, moreitem) {\n  console.log([...list, ...args, moreitem]);\n}\n\ngetItems([\"berry\", \"apple\"], \"pear\", \"kiwi\");\n```",
        "options": {
            "A": "Logs [\"berry\", \"apple\", \"pear\", \"kiwi\"]",
            "B": "Logs [\"pear\", \"kiwi\", undefined]",
            "C": "SyntaxError due to incorrect rest parameter position",
            "D": "TypeError during spread operation"
        },
        "answer": "C",
        "explanation": "Rest parameters must be the last formal parameter. Having `moreitem` after `...args` causes a SyntaxError.",
        "difficulty": "hard",
        "category": "Rest/Spread"
    },
    {
        "id": 83,
        "question": "What will be logged?\n\n```js\nconst [x, ...y] = [1, 2, 3, 4, 5];\nconsole.log({ x, y });\n```",
        "options": {
            "A": "{ x: 1, y: [2, 3, 4, 5] }",
            "B": "{ x: 2, y: [1, 3, 4, 5] }",
            "C": "{ x: 1, y: [1, 2, 3, 4, 5] }",
            "D": "{ x: [1, 2], y: [3, 4, 5] }"
        },
        "answer": "A",
        "explanation": "`x` gets the first value (1), and the rest (`[2, 3, 4, 5]`) goes into `y` using the rest operator.",
        "difficulty": "easy",
        "category": "Destructuring"
    },
    {
        "id": 84,
        "question": "What will this code log?\n\n```js\nlet num = [1, 2];\nnum.reduce((acc, next) => {\n  console.log(acc);\n  console.log(next);\n});\n```",
        "options": {
            "A": "1, 2",
            "B": "undefined, undefined",
            "C": "Throws error because no initial value is provided",
            "D": "2, 1"
        },
        "answer": "A",
        "explanation": "When no initial value is passed, `reduce` uses the first item as `acc` and second as `next`. So `1` and `2` are logged.",
        "difficulty": "medium",
        "category": "Array.reduce"
    },
    {
        "id": 85,
        "question": "What will be the output?\n\n```js\nlet r = [1, 2, 3, 4, 5][1, 2];\nconsole.log(r);\n```",
        "options": {
            "A": "1",
            "B": "2",
            "C": "3",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "`[1, 2]` is an expression. The comma operator returns the last value, so this becomes `[1,2,3,4,5][2]` which is `3`.",
        "difficulty": "hard",
        "category": "Comma Operator"
    },
    {
        "id": 85,
        "question": "What will be the output?\n\n```js\nlet r = [1, 2, 3, 4, 5][1, 2];\nconsole.log(r);\n```",
        "options": {
            "A": "1",
            "B": "2",
            "C": "3",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "`[1, 2]` is an expression. The comma operator returns the last value, so this becomes `[1,2,3,4,5][2]` which is `3`.",
        "difficulty": "medium",
        "category": "comma operator"
    },
    {
        "id": 86,
        "question": "What will be logged?\n\n```js\nlet num = 1;\nconst list = [\"a\", \"b\", \"c\"];\nconsole.log(list[num += 1]);\n```",
        "options": {
            "A": "\"a\"",
            "B": "\"b\"",
            "C": "\"c\"",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "`num += 1` increases `num` to 2, so `list[2]` is \"c\"",
        "difficulty": "easy",
        "category": "operators and arrays"
    },
    {
        "id": 87,
        "question": "What will be the output?\n\n```js\nfunction superhero() {\n  this.hero = \"Hanuman\";\n  return { hero: \"Lord\" };\n}\nconst output = new superhero();\nconsole.log(output);\n```",
        "options": {
            "A": "{ hero: 'Hanuman' }",
            "B": "{ hero: 'Lord' }",
            "C": "undefined",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "When a constructor function returns an explicit object, that object is returned instead of 'this'. So, the output is { hero: 'Lord' }.",
        "difficulty": "medium",
        "category": "constructor function"
    },
    {
        "id": 88,
        "question": "What will be the output?\n\n```js\nconst data = { name: \"neel\" };\nconsole.log(delete data.name);\nconsole.log(data);\n```",
        "options": {
            "A": "false, { name: 'neel' }",
            "B": "true, {}",
            "C": "true, { }",
            "D": "false, {}"
        },
        "answer": "C",
        "explanation": "The `delete` operator removes the `name` property and returns `true`. The object becomes empty after deletion.",
        "difficulty": "easy",
        "category": "delete operator"
    },
    {
        "id": 89,
        "question": "What will be the output?\n\n```js\nconst data = { name: \"neel\" };\nconsole.log(delete data);\nconsole.log(data);\n```",
        "options": {
            "A": "true, { name: 'neel' }",
            "B": "false, { name: 'neel' }",
            "C": "true, undefined",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "You cannot delete a variable declared with `const` or `let`. The `delete` operator returns `false` and the variable remains unchanged.",
        "difficulty": "medium",
        "category": "delete operator"
    },
    {
        "id": 90,
        "question": "What will be the output?\n\n```js\nlet data = { fname: \"neel\", age: 23 };\nlet info = { city: \"om\" };\ndata = { data, ...info };\nconsole.log(data);\n```",
        "options": {
            "A": "{ fname: 'neel', age: 23, city: 'om' }",
            "B": "{ data: { fname: 'neel', age: 23 }, city: 'om' }",
            "C": "{ fname: 'neel', age: 23, city: 'om', data: {...} }",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "The `data` variable becomes a new object with a `data` key (holding the original `data` object) and a `city` key from the `info` object.",
        "difficulty": "medium",
        "category": "spread operator"
    },
    {
        "id": 91,
        "question": "What will be the output?\n\n```js\nlet data = { fname: \"neel\", age: 23 };\nlet info = { lname: 'samel', age: 25 };\ndata = { ...data, ...info };\nconsole.log(data);\n```",
        "options": {
            "A": "{ fname: 'neel', age: 23, lname: 'samel' }",
            "B": "{ fname: 'neel', lname: 'samel', age: 25 }",
            "C": "{ lname: 'samel', age: 25 }",
            "D": "{ fname: 'neel', age: 25, lname: 'samel' }"
        },
        "answer": "B",
        "explanation": "When spreading objects, keys in later objects overwrite earlier ones. Here, `age: 25` from `info` overwrites `age: 23` from `data`.",
        "difficulty": "easy",
        "category": "spread"
    },
    {
        "id": 92,
        "question": "What will be the output?\n\n```js\nlet person = { name: \"neel\" };\nObject.seal(person);\nperson.age = 23;\nperson.name = \"neelu\";\nconsole.log(person);\n```",
        "options": {
            "A": "{ name: 'neel', age: 23 }",
            "B": "{ name: 'neelu' }",
            "C": "{ name: 'neel' }",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "After `Object.seal`, you cannot add new properties, but you can modify existing ones. So, `name` changes to 'neelu', but `age` is not added.",
        "difficulty": "medium",
        "category": "objects"
    },
    {
        "id": 93,
        "question": "What will be the output?\n\n```js\nconst box = { x: 10, y: 20 };\nObject.freeze(box);\nconst Shape = box;\nbox.x = 30;\nShape.y = 50;\nconsole.log(box);\n```",
        "options": {
            "A": "{ x: 10, y: 20 }",
            "B": "{ x: 30, y: 50 }",
            "C": "{ x: 10, y: 50 }",
            "D": "{ x: 30, y: 20 }"
        },
        "answer": "A",
        "explanation": "`Object.freeze` prevents any modification or addition to the object. Changes to `box` or `Shape` do not affect the original object.",
        "difficulty": "medium",
        "category": "objects"
    },
    {
        "id": 94,
        "question": "What will be logged?\n\n```js\nlet data = \"student\";\nconst person = {\n  student: \"neel\"\n};\nconsole.log(person.student);\nconsole.log(person[data]);\nconsole.log(person[\"student\"]);\nconsole.log(person.data);\n```",
        "options": {
            "A": "neel, neel, neel, undefined",
            "B": "undefined, neel, neel, neel",
            "C": "neel, undefined, neel, undefined",
            "D": "undefined, undefined, undefined, undefined"
        },
        "answer": "A",
        "explanation": "Accessing properties by dot notation or bracket notation with the exact key works. `person.data` looks for a property literally named 'data', which doesn't exist.",
        "difficulty": "easy",
        "category": "objects"
    },
    {
        "id": 95,
        "question": "What will be the output?\n\n```js\nfunction age(...args) {\n  console.log(typeof args);\n}\nage(22);\n```",
        "options": {
            "A": "\"number\"",
            "B": "\"object\"",
            "C": "\"array\"",
            "D": "\"undefined\""
        },
        "answer": "B",
        "explanation": "The rest parameter collects arguments into an array, and `typeof` an array returns 'object' in JavaScript.",
        "difficulty": "easy",
        "category": "rest-parameters"
    },
    {
        "id": 96,
        "question": "What will happen when this code runs?\n\n```js\nconst person = {\n  name: \"neel\",\n  age: 23\n};\nfor (let items of person) {\n  console.log(items);\n}\n```",
        "options": {
            "A": "Logs 'name' and 'age'",
            "B": "Logs 'neel' and 23",
            "C": "Throws TypeError: person is not iterable",
            "D": "Logs nothing"
        },
        "answer": "C",
        "explanation": "Objects are not iterable with `for...of` loops. This code throws a TypeError.",
        "category": "for...of & iterables",
        "difficulty": "medium"
    },
    {
        "id": 97,
        "question": "What will be the output?\n\n```js\nconst obje = {1: \"a\", 2: \"b\", 3: \"c\"};\nconsole.log(obje.hasOwnProperty(\"1\"));\nconsole.log(obje.hasOwnProperty(1));\n```",
        "options": {
            "A": "true, false",
            "B": "false, true",
            "C": "true, true",
            "D": "false, false"
        },
        "answer": "C",
        "explanation": "Object keys are strings in JavaScript, so \"1\" and 1 are equivalent keys. Hence, both calls return true.",
        "category": "object keys & coercion",
        "difficulty": "medium"
    },
    {
        "id": 98,
        "question": "What will be logged?\n\n```js\nfunction car() {\n  this.make = 'audi';\n  return { make: 'bmw' };\n}\nconst mycar = new car();\nconsole.log(mycar.make);\n```",
        "options": {
            "A": "audi",
            "B": "bmw",
            "C": "undefined",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "When a constructor returns an object explicitly, that object is returned instead of `this`. So `mycar.make` is 'bmw'.",
        "category": "constructors & return behavior",
        "difficulty": "medium"
    },
    {
        "id": 99,
        "question": "What will be the output?\n\n```js\nlet c = { greeting: \"Hey\" };\nlet d;\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n```",
        "options": {
            "A": "\"Hey\"",
            "B": "\"Hello\"",
            "C": "undefined",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "Objects are assigned by reference, so `d` points to the same object as `c`. Changing `c.greeting` affects `d.greeting`.",
        "category": "object references",
        "difficulty": "easy"
    },
    {
        "id": 100,
        "question": "What will be the output?\n\n```js\nconst income = {\n  skills: 12,\n  monthly() {\n    return this.skills * 2;\n  },\n  yearly: () => this.skills * 2,\n};\n\nconsole.log(income.monthly());\nconsole.log(income.yearly());\n```",
        "options": {
            "A": "24, 24",
            "B": "24, NaN",
            "C": "NaN, 24",
            "D": "NaN, NaN"
        },
        "answer": "B",
        "explanation": "`monthly` is a regular function where `this` refers to `income`, so it returns 24. Arrow function `yearly` inherits `this` from surrounding scope (likely `window`), where `skills` is undefined, resulting in NaN.",
        "category": "this binding (arrow vs normal)",
        "difficulty": "hard"
    },
    {
        "id": 101,
        "question": "What will be the output?\n\n```js\nconst A = {};\nconst B = { key: \"b\" };\nconst C = { key: \"c\" };\n\nA[B] = 123;\nA[C] = 456;\n\nconsole.log(A[B]);\n```",
        "options": {
            "A": "123",
            "B": "456",
            "C": "undefined",
            "D": "[object Object]"
        },
        "answer": "B",
        "explanation": "Object keys are converted to strings. Both `B` and `C` convert to '[object Object]', so `A[C] = 456` overwrites the previous value. Hence `A[B]` is 456.",
        "category": "object reference",
        "difficulty": "medium"
    },
    {
        "id": 102,
        "question": "What will be the output?\n\n```js\nconst func = ((a) => {\n  delete a;\n  return a;\n})(5);\n\nconsole.log(func);\n```",
        "options": {
            "A": "undefined",
            "B": "5",
            "C": "Throws error",
            "D": "null"
        },
        "answer": "B",
        "explanation": "The `delete` operator only works on object properties, not on local variables or function parameters. So `a` remains 5.",
        "category": "operators",
        "difficulty": "medium"
    },
    {
        "id": 103,
        "question": "What will this code log?\n\n```js\nconst user = {\n  name: \"sonu\",\n  age: 24,\n  fullname() {\n    const nestedarrow = () => console.log(this.name);\n    nestedarrow();\n  },\n};\n\nuser.fullname();\n```",
        "options": {
            "A": "\"sonu\"",
            "B": "undefined",
            "C": "Throws error",
            "D": "null"
        },
        "answer": "A",
        "explanation": "Arrow functions inherit `this` from their lexical scope. Here, `nestedarrow` uses `this` from `fullname` method, which refers to `user`.",
        "category": "this",
        "difficulty": "easy"
    },
    {
        "id": 104,
        "question": "What will be the output?\n\n```js\nconst key = \"constructor\";\nconst obj = {};\n\nif (obj[key]) {\n  console.log(\"Key Exist\");\n} else {\n  console.log(\"Key not found\");\n}\n\nif (key in obj) {\n  console.log(\"Key Exist\");\n} else {\n  console.log(\"Key not found\");\n}\n```",
        "options": {
            "A": "Key not found\\nKey not found",
            "B": "Key Exist\\nKey Exist",
            "C": "Key not found\\nKey Exist",
            "D": "Key Exist\\nKey not found"
        },
        "answer": "C",
        "explanation": "`obj[key]` checks for own properties (undefined here), but `key in obj` checks prototype chain. The prototype has 'constructor', so second logs 'Key Exist'.",
        "category": "prototype",
        "difficulty": "medium"
    },
    {
        "id": 105,
        "question": "What will be logged?\n\n```js\nconst animals = {};\nlet dog = { emoji: 'ðŸ•â€ðŸ¦º' };\nlet cat = { emoji: 'ðŸ¦Š' };\n\nanimals[dog] = { ...dog, name: \"Bull_dog\" };\nanimals[cat] = { ...cat, name: \"Simbha\" };\n\nconsole.log(animals[dog]);\n```",
        "options": {
            "A": "{ emoji: 'ðŸ•â€ðŸ¦º', name: 'Bull_dog' }",
            "B": "{ emoji: 'ðŸ¦Š', name: 'Simbha' }",
            "C": "undefined",
            "D": "{}"
        },
        "answer": "B",
        "explanation": "Object keys are stringified; both `dog` and `cat` become '[object Object]'. The second assignment overwrites the first, so accessing with `dog` key returns the cat's value.",
        "category": "object reference",
        "difficulty": "medium"
    },
    {
        "id": 106,
        "category": "Objects",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nconst { fname: Name } = { fname: \"Neel\" };\nconsole.log(Name);\n```",
        "options": {
            "A": "\"fname\"",
            "B": "\"Name\"",
            "C": "\"Neel\"",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "This uses object destructuring with renaming. `fname` property value \"Neel\" is assigned to variable `Name`."
    },
    {
        "id": 107,
        "category": "Objects",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nconst student = {\n  10: \"Purnima\"\n};\nstudent.20 = \"krushnai\";\nconsole.log(student);\n```",
        "options": {
            "A": "{ '10': 'Purnima', 20: 'krushnai' }",
            "B": "{ '10': 'Purnima', '20': 'krushnai' }",
            "C": "SyntaxError",
            "D": "{ 10: 'Purnima', 20: 'krushnai' }"
        },
        "answer": "B",
        "explanation": "Object keys are always strings. Numeric keys like `10` and `20` get converted to strings internally. Adding `student.20` is invalid syntax; the correct way is `student[20] = 'krushnai'`."
    },
    {
        "id": 108,
        "category": "Objects",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nlet isPass = false;\nconsole.log(isPass.randomKey);\nconsole.log(isPass.constructor);\n```",
        "options": {
            "A": "undefined, [Function: Boolean]",
            "B": "undefined, undefined",
            "C": "Throws error, [Function: Boolean]",
            "D": "false, [Function: Boolean]"
        },
        "answer": "A",
        "explanation": "Primitive `false` is boxed to `Boolean` object temporarily. `randomKey` doesnâ€™t exist so it's `undefined`, but `constructor` is a valid property on the Boolean prototype."
    },
    {
        "id": 109,
        "category": "Objects",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nconst obj = { name: \"X\" };\ndelete obj.name;\nobj.name = \"Y\";\nconsole.log(obj);\n```",
        "options": {
            "A": "{}",
            "B": "{ name: 'Y' }",
            "C": "{ name: 'X' }",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "Property `name` is deleted, then reassigned. So the final object has `{ name: 'Y' }`."
    },
    {
        "id": 110,
        "category": "Objects",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nconsole.log(`${{Object}}`);\n\nconst obj = {};\nobj.Object = () => {};\nconsole.log(obj.toString());\n```",
        "options": {
            "A": "`[object Object]` and `[object Object]`",
            "B": "`object Object` and `[object Object]`",
            "C": "`[object Object]` and `function`",
            "D": "`object Object` and `function`"
        },
        "answer": "B",
        "explanation": "Template string interpolation with an object results in `'object Object'`. The `toString` method returns the default `[object Object]` since the custom `Object` key doesn't affect it."
    },
    {
        "id": 111,
        "question": "What will be the output?\n\n```js\nconst user = { name: \"neel\", age: 25 };\nconst admin = { admin: true, ...user };\nconsole.log(admin);\n```",
        "options": {
            "A": "{ admin: true }",
            "B": "{ name: 'neel', age: 25 }",
            "C": "{ admin: true, name: 'neel', age: 25 }",
            "D": "{ admin: true, user: { name: 'neel', age: 25 } }"
        },
        "answer": "C",
        "explanation": "The spread operator `...user` copies all properties of `user` into `admin`, resulting in an object with all three properties.",
        "difficulty": "easy",
        "category": "spread"
    },
    {
        "id": 112,
        "question": "What will happen when running this code?\n\n```js\nconsole.log(person);\nclass person {\n}\n```",
        "options": {
            "A": "Logs the class definition",
            "B": "Throws ReferenceError",
            "C": "Logs undefined",
            "D": "Logs an empty object"
        },
        "answer": "B",
        "explanation": "Class declarations are not hoisted like function declarations, so accessing `person` before its definition causes a ReferenceError.",
        "difficulty": "medium",
        "category": "class"
    },
    {
        "id": 113,
        "question": "What will happen when this function is called?\n\n```js\nconst myfunc = ({ x, y, z }) => {\n  console.log(x, y, z);\n};\n\nmyfunc(1, 2, 3);\n```",
        "options": {
            "A": "Logs 1 2 3",
            "B": "Logs undefined undefined undefined",
            "C": "Throws TypeError",
            "D": "Logs [1,2,3]"
        },
        "answer": "C",
        "explanation": "The function expects a single object parameter to destructure. Passing 3 separate arguments causes a TypeError.",
        "difficulty": "medium",
        "category": "destructuring"
    },
    {
        "id": 114,
        "question": "What will be the output?\n\n```js\nfunction init(x, y, z) {}\nfunction end(a, b = 3, c) {}\n\nconsole.log(init.length);\nconsole.log(end.length);\n```",
        "options": {
            "A": "3 and 3",
            "B": "3 and 2",
            "C": "2 and 3",
            "D": "2 and 2"
        },
        "answer": "B",
        "explanation": "The `length` property counts parameters before the first one with a default value. `init` has 3 parameters, `end` has 2 before default.",
        "difficulty": "hard",
        "category": "function-properties"
    },
    {
        "id": 115,
        "question": "What will be the output?\n\n```js\nconst shape = {\n  radius: 10,\n  daimeter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius,\n};\n\nconsole.log(shape.daimeter());\nconsole.log(shape.perimeter());\n```",
        "options": {
            "A": "20 and NaN",
            "B": "NaN and 62.83",
            "C": "20 and 62.83",
            "D": "Throws error"
        },
        "answer": "A",
        "explanation": "`daimeter` (typo for diameter) is a regular method and works correctly. However, `perimeter` is an arrow function and doesn't bind `this` to `shape`, so `this.radius` is `undefined` in it.",
        "difficulty": "hard",
        "category": "arrow-function-this"
    },
    {
        "id": 116,
        "question": "What will be the output?\n\n```js\nconst obj = {};\nobj[obj[\"a\"] = \"B\"] = \"C\";\nconsole.log(obj);\n```",
        "options": {
            "A": "{ a: 'B', B: 'C' }",
            "B": "{ B: 'C' }",
            "C": "{ 'undefined': 'C' }",
            "D": "{}"
        },
        "answer": "B",
        "explanation": "The expression `obj[\"a\"] = \"B\"` assigns 'B' to key 'a' and returns 'B', so the statement becomes `obj['B'] = 'C'`. The final object is `{ B: 'C' }`.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 117,
        "question": "What will be logged?\n\n```js\nlet x = (y = {});\ny.name = \"Neel\";\nconsole.log(x.name);\n```",
        "options": {
            "A": "undefined",
            "B": "\"Neel\"",
            "C": "Throws ReferenceError",
            "D": "null"
        },
        "answer": "B",
        "explanation": "`y` is assigned to a new object and then `x` is assigned the same object reference. So changing `y.name` affects `x.name`.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 118,
        "question": "What will be the output?\n\n```js\nconst { a = \"d\", b = \"d\", c = \"d\", d = \"d\", e = \"d\" } = { a: null, b: undefined, c: false, d: 0 };\nconsole.log({ a, b, c, d, e });\n```",
        "options": {
            "A": "{ a: null, b: \"d\", c: false, d: 0, e: \"d\" }",
            "B": "{ a: \"d\", b: \"d\", c: \"d\", d: \"d\", e: \"d\" }",
            "C": "{ a: null, b: undefined, c: false, d: 0, e: undefined }",
            "D": "{ a: null, b: undefined, c: false, d: 0, e: \"d\" }"
        },
        "answer": "A",
        "explanation": "Default values are used only if the value is `undefined`. Here, `a` is null (not undefined), so default not applied; `b` is undefined, so default applied; `c` and `d` are falsy but not undefined, so default not applied; `e` is missing, so default applied.",
        "category": "Destructuring",
        "difficulty": "Medium"
    },
    {
        "id": 119,
        "question": "What will be the output?\n\n```js\nfunction changeAgeAndReference(person) {\n  person = {\n    name: \"neel\",\n    age: 25\n  };\n  return person;\n}\n\nconst person1 = {\n  name: \"sonu\",\n  age: 24\n};\n\nconst person2 = changeAgeAndReference(person1);\n\nconsole.log(person1);\nconsole.log(person2);\n```",
        "options": {
            "A": "{ name: 'sonu', age: 24 }, { name: 'neel', age: 25 }",
            "B": "{ name: 'neel', age: 25 }, { name: 'neel', age: 25 }",
            "C": "{ name: 'sonu', age: 24 }, { name: 'sonu', age: 24 }",
            "D": "Throws error"
        },
        "answer": "A",
        "explanation": "Inside the function, `person` is reassigned to a new object, so `person1` outside remains unchanged, while `person2` gets the new object.",
        "category": "Reference vs Value",
        "difficulty": "Medium"
    },
    {
        "id": 120,
        "question": "What will be logged?\n\n```js\nconst x = {};\nx.__proto__.h1 = 10;\nconsole.log(x.h1, x);\nObject.prototype.h1 = ++x.h1;\nconsole.log(x.h1, x);\nconsole.log(x.h1 + Object.keys(x).length);\n```",
        "options": {
            "A": "10, {}, 11, {}, 11",
            "B": "10, {}, 11, {}, 12",
            "C": "undefined, {}, 10, {}, 10",
            "D": "10, {}, 10, {}, 20"
        },
        "answer": "B",
        "explanation": "`x.h1` initially reads 10 from prototype. Increment sets `Object.prototype.h1` to 11. Then sum adds 11 + 1 (own keys count).",
        "category": "Prototype",
        "difficulty": "Hard"
    },
    {
        "id": 121,
        "question": "What will be logged?\n\n```js\nconst dataMap = new WeakMap();\n\nlet Person = { Name: \"neel\" };\ndataMap.set(Person, \"Neha\");\n\nconsole.log(dataMap.get(Person));\nPerson = null;\nconsole.log(dataMap.get(Person));\n```",
        "options": {
            "A": "\"Neha\", undefined",
            "B": "undefined, undefined",
            "C": "\"Neha\", Throws error",
            "D": "Throws error, undefined"
        },
        "answer": "B",
        "explanation": "WeakMap holds keys weakly. When `Person` is set to null, the object is eligible for garbage collection, so `dataMap.get(null)` returns undefined.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 122,
        "question": "What will be the output?\n\n```js\nconst obj = {};\nObject.defineProperty(obj, \"a\", { value: \"char\", enumerable: true });\nconsole.log(obj.a);\nconsole.log(Object.keys(obj));\n```",
        "options": {
            "A": "\"char\", [\"a\"]",
            "B": "\"char\", []",
            "C": "undefined, [\"a\"]",
            "D": "undefined, []"
        },
        "answer": "A",
        "explanation": "The property \"a\" is defined with `enumerable: true`, so it appears in `Object.keys` and logs its value correctly.",
        "category": "Objects",
        "difficulty": "Easy"
    },
    {
        "id": 123,
        "question": "What will happen when this code runs?\n\n```js\nconst obj = Object.create(null);\nconst keytoCheck = \"randomkey\";\n\nif (obj.hasOwnProperty(keytoCheck)) {\n  console.log(\"KeyFound\");\n} else {\n  console.log(\"Key Not Found\");\n}\n```",
        "options": {
            "A": "\"KeyFound\"",
            "B": "\"Key Not Found\"",
            "C": "Throws TypeError",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "`obj` created with `Object.create(null)` has no prototype, so `hasOwnProperty` is undefined, causing a TypeError.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 124,
        "question": "What will be logged?\n\n```js\nconst a = { fn: function () {} };\nconst b = [function () {}];\n\nconst strA = JSON.stringify(a);\nconst strB = JSON.stringify(b);\n\nconsole.log(strA);\nconsole.log(strB);\n```",
        "options": {
            "A": "\"{}\", \"[null]\"",
            "B": "\"{\\\"fn\\\":null}\", \"[null]\"",
            "C": "\"{}\", \"[]\"",
            "D": "\"{\\\"fn\\\":{}}\", \"[{}]\""
        },
        "answer": "A",
        "explanation": "Functions are omitted in object serialization, resulting in '{}', but in arrays, they convert to `null`, so '[null]'.",
        "category": "JSON",
        "difficulty": "Medium"
    },
    {
        "id": 125,
        "question": "Consider the following:\n\n```js\nconst obj = {\n  name: \"Neel\",\n  surname: {\n    lastname: \"Samel\"\n  }\n};\n\nfunction freeze(val) {\n  Object.keys(val).forEach((key) => {\n    if (typeof val[key] === \"object\") {\n      freeze(val[key]);\n    }\n  });\n}\n\nfreeze(obj);\nobj.surname.lastname = \"Sinha\";\nconsole.log(obj);\n```\n\nWhat will be the output and why?",
        "options": {
            "A": "{ name: \"Neel\", surname: { lastname: \"Sinha\" } } â€” nested keys are mutable because freeze wasn't applied properly",
            "B": "Throws error â€” freeze prevents mutation",
            "C": "{ name: \"Neel\", surname: { lastname: \"Samel\" } } â€” fully frozen, no mutation",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "The `freeze` function does not actually call `Object.freeze()`, so nested objects remain mutable, allowing `lastname` to be changed.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 126,
        "category": "function basics",
        "difficulty": "Easy",
        "question": "What will be the output?\n\n```js\nfunction sum(x, y, z) {\n    return x + y + z;\n}\nconsole.log(sum(1, 2, 3));\n```",
        "options": {
            "A": "6",
            "B": "123",
            "C": "NaN",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "The function adds three numbers correctly, so the output is 6."
    },
    {
        "id": 127,
        "category": "function properties",
        "difficulty": "Easy",
        "question": "What will be logged?\n\n```js\nfunction fruits() {\n    console.log(\"neel\");\n}\nfruits.name = \"orange\";\nfruits();\n```",
        "options": {
            "A": "\"orange\"",
            "B": "\"neel\"",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Functionâ€™s `name` property is not used inside the function body; the call logs \"neel\"."
    },
    {
        "id": 128,
        "category": "error handling",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\n(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n```",
        "options": {
            "A": "1, undefined, 2",
            "B": "Error, undefined, 2",
            "C": "1, 1, 2",
            "D": "undefined, undefined, undefined"
        },
        "answer": "A",
        "explanation": "Catch block parameter `x` shadows outer `x`. Inside catch logs 1, outer `x` remains undefined, `y` is assigned 2 and logged."
    },
    {
        "id": 129,
        "category": "try-catch",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nfunction getmessage() {\n  throw \"Hello world\";\n}\nfunction sayhello() {\n  try {\n    const data = getmessage();\n    console.log(`Welcome to ${data}`);\n  } catch (error) {\n    console.log(`Error ${error}`);\n  }\n}\nsayhello();\n```",
        "options": {
            "A": "Welcome to Hello world",
            "B": "Error Hello world",
            "C": "SyntaxError",
            "D": "No output"
        },
        "answer": "B",
        "explanation": "`getmessage` throws a string, caught in `sayhello`, so catch logs 'Error Hello world'."
    },
    {
        "id": 131,
        "category": "scope",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\n(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n```",
        "options": {
            "A": "\"number\", \"number\"",
            "B": "\"undefined\", \"number\"",
            "C": "\"undefined\", \"undefined\"",
            "D": "\"number\", \"undefined\""
        },
        "answer": "B",
        "explanation": "Inside the IIFE, `x` is block scoped and not accessible outside, so `typeof x` is \"undefined\". `y` is assigned without var/let/const, making it global, so `typeof y` is \"number\"."
    },
    {
        "id": 132,
        "category": "return statement",
        "difficulty": "Easy",
        "question": "What will this code output?\n\n```js\nfunction chk(a, b) {\n  if (a > b) console.log(\"A is greater\");\n  else console.log(\"B is greater\");\n  return;\n  a + b;\n}\n\nconsole.log(chk(2, 3));\n```",
        "options": {
            "A": "\"A is greater\", undefined",
            "B": "\"B is greater\", undefined",
            "C": "\"B is greater\", NaN",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Since 2 < 3, it logs \"B is greater\". The function returns undefined because the line after `return` is unreachable."
    },
    {
        "id": 133,
        "category": "function expression",
        "difficulty": "Medium",
        "question": "What will happen?\n\n```js\nif (function fn() {}) {\n  console.log(fn);\n}\n```",
        "options": {
            "A": "Logs the function fn",
            "B": "ReferenceError: fn is not defined",
            "C": "Does nothing",
            "D": "SyntaxError"
        },
        "answer": "B",
        "explanation": "Function expressions inside conditions are not hoisted with a name; `fn` is not defined in that scope, causing ReferenceError."
    },
    {
        "id": 134,
        "category": "hoisting",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nvar magic = 900;\nfunction magic() {\n  console.log(\"Neel\");\n}\n\nconsole.log(magic);\n```",
        "options": {
            "A": "\"Neel\"",
            "B": "900",
            "C": "function magic() { console.log(\"Neel\"); }",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "Variable declaration `var magic = 900` overrides the function declaration `magic`. So `magic` is 900."
    },
    {
        "id": 131,
        "category": "scope",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\n(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n```",
        "options": {
            "A": "\"number\", \"number\"",
            "B": "\"undefined\", \"number\"",
            "C": "\"undefined\", \"undefined\"",
            "D": "\"number\", \"undefined\""
        },
        "answer": "B",
        "explanation": "Inside the IIFE, `x` is block scoped and not accessible outside, so `typeof x` is \"undefined\". `y` is assigned without var/let/const, making it global, so `typeof y` is \"number\"."
    },
    {
        "id": 132,
        "category": "functions",
        "difficulty": "Easy",
        "question": "What will this code output?\n\n```js\nfunction chk(a, b) {\n  if (a > b) console.log(\"A is greater\");\n  else console.log(\"B is greater\");\n  return;\n  a + b;\n}\n\nconsole.log(chk(2, 3));\n```",
        "options": {
            "A": "\"A is greater\", undefined",
            "B": "\"B is greater\", undefined",
            "C": "\"B is greater\", NaN",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Since 2 < 3, it logs \"B is greater\". The function returns undefined because the line after `return` is unreachable."
    },
    {
        "id": 133,
        "category": "functions",
        "difficulty": "Medium",
        "question": "What will happen?\n\n```js\nif (function fn() {}) {\n  console.log(fn);\n}\n```",
        "options": {
            "A": "Logs the function fn",
            "B": "ReferenceError: fn is not defined",
            "C": "Does nothing",
            "D": "SyntaxError"
        },
        "answer": "B",
        "explanation": "Function expressions inside conditions are not hoisted with a name; `fn` is not defined in that scope, causing ReferenceError."
    },
    {
        "id": 134,
        "category": "hoisting",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nvar magic = 900;\nfunction magic() {\n  console.log(\"Neel\");\n}\n\nconsole.log(magic);\n```",
        "options": {
            "A": "\"Neel\"",
            "B": "900",
            "C": "function magic() { console.log(\"Neel\"); }",
            "D": "undefined"
        },
        "answer": "B",
        "explanation": "Variable declaration `var magic = 900` overrides the function declaration `magic`. So `magic` is 900."
    },
    {
        "id": 135,
        "category": "Hoisting",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nagaintest();\ntest();\nconst test = function () {\n  console.log(\"Hii Devin\");\n};\n\nfunction againtest() {\n  console.log(\"Hii neel\");\n}\n```",
        "options": {
            "A": "\"Hii neel\" then \"Hii Devin\"",
            "B": "ReferenceError for test, then \"Hii neel\"",
            "C": "Throws error at againtest call",
            "D": "\"Hii Devin\" then \"Hii neel\""
        },
        "answer": "B",
        "explanation": "`againtest` is a function declaration and hoisted, so it runs fine. `test` is a function expression with `const`, so it is not initialized at call time and throws ReferenceError."
    },
    {
        "id": 136,
        "category": "IIFE",
        "difficulty": "Medium",
        "question": "How can you convert this function declaration into a function expression and invoke it immediately?\n\n```js\n// Original function declaration (will cause syntax error if invoked immediately)\nfunction() {\n    console.log(\"Hii neel\");\n}()\n\n// Converted to function expression\n!function() {\n    console.log(\"Hii neel\");\n}()\n```",
        "options": {
            "A": "Use ! before function to convert it to an expression",
            "B": "Use function name before ()",
            "C": "Wrap function in square brackets []",
            "D": "No need to do anything"
        },
        "answer": "A",
        "explanation": "Adding ! before function converts the declaration to a function expression which can be immediately invoked without syntax error."
    },
    {
        "id": 137,
        "category": "setInterval",
        "difficulty": "Easy",
        "question": "How do you stop a setInterval function?\n\n```js\nlet num = 0;\nfunction show() {\n  setInterval(function () {\n    console.log(\"Number\");\n    console.log(num++);\n\n    if (num > 5) {\n      clearInterval(id);\n    }\n  }, 1000);\n}\nshow();\n```",
        "options": {
            "A": "Using clearInterval with interval id",
            "B": "Using clearTimeout with interval id",
            "C": "Return from function",
            "D": "Using break statement"
        },
        "answer": "A",
        "explanation": "You must save the interval ID returned by setInterval and pass it to clearInterval to stop it."
    },
    {
        "id": 138,
        "category": "window object",
        "difficulty": "Easy",
        "question": "How to call a function using the Window object?\n\n```js\nfunction show() {\n  console.log(\"Neel\");\n}\n\nconst FunName = \"show\";\nwindow[FunName]();\n```",
        "options": {
            "A": "Call function directly by name",
            "B": "Use window object with function name string",
            "C": "Use eval()",
            "D": "Cannot call function this way"
        },
        "answer": "B",
        "explanation": "Global functions are properties of the window object in browsers, so calling via window['functionName'] works."
    },
    {
        "id": 139,
        "category": "console",
        "difficulty": "Medium",
        "question": "What will happen here?\n\n```js\nfunction grandparent() {\n  console.log(\"grandParent\");\n  parent();\n}\n\nfunction parent() {\n  console.log(\"grandParent\");\n  child();\n}\n\nfunction child() {\n  console.log(\"grandParent\");\n  innerchild();\n}\n\nfunction innerchild() {\n  console.trace();\n}\n\ngrandparent();\n```",
        "options": {
            "A": "Logs call stack trace from innerchild to grandparent",
            "B": "Only logs 'grandParent' once",
            "C": "Throws error due to recursion",
            "D": "No output"
        },
        "answer": "A",
        "explanation": "`console.trace()` outputs the stack trace showing the chain of function calls from innerchild up to grandparent."
    },
    {
        "id": 140,
        "category": "try-catch-finally",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nfunction test() {\n  try {\n    return 1;\n  } finally {\n    return 2;\n  }\n}\n\nconst res = test();\nconsole.log(res);\n```",
        "options": {
            "A": "1",
            "B": "2",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The `finally` block runs after `try` and its return value overrides the `try` return, so `2` is returned."
    },
    {
        "id": 141,
        "category": "function parameters",
        "difficulty": "Medium",
        "question": "What happens if you declare a function or arrow function with duplicate parameter names?\n\n```js\nconst show = (b, b) => {}\n\nfunction test(a, a) {}\n```",
        "options": {
            "A": "No error, works fine",
            "B": "SyntaxError for arrow function only",
            "C": "SyntaxError for both functions",
            "D": "Only last parameter is considered"
        },
        "answer": "C",
        "explanation": "JavaScript throws a SyntaxError if function parameters have duplicate names, both in regular and arrow functions."
    },
    {
        "id": 142,
        "category": "function parameters",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nfunction test(a, a) {\n    console.log(a);\n}\ntest(5);\n```",
        "options": {
            "A": "5",
            "B": "undefined",
            "C": "SyntaxError",
            "D": "null"
        },
        "answer": "C",
        "explanation": "Duplicate parameters are not allowed in strict mode (which is default in ES6 modules and arrow functions) and will cause a SyntaxError."
    },
    {
        "id": 143,
        "category": "function name",
        "difficulty": "Easy",
        "question": "What will this code output?\n\n```js\nfunction JS() {\n    console.log(\"Hii\");\n}\n\nconsole.log(JS.name);\n```",
        "options": {
            "A": "\"Hii\"",
            "B": "\"JS\"",
            "C": "\"undefined\"",
            "D": "\"function\""
        },
        "answer": "B",
        "explanation": "The `name` property of a function returns its declared name, here \"JS\"."
    },
    {
        "id": 144,
        "category": "function invocation",
        "difficulty": "Easy",
        "question": "How to call a function without parentheses?\n\n```js\nfunction show() {\n    console.log(\"Hii neel\");\n}\n\nnew show;\n```",
        "options": {
            "A": "Using `new` keyword invokes function without parentheses",
            "B": "Call function normally without parentheses",
            "C": "Cannot call function without parentheses",
            "D": "Use call() or apply() methods"
        },
        "answer": "A",
        "explanation": "Using `new` keyword to instantiate a function calls it even without parentheses."
    },
    {
        "id": 145,
        "category": "scope and hoisting",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nfunction a() {\n  var var1 = 2, var2 = 3;\n}\n\nfunction b() {\n  var var1 = var2 = 1;\n}\na();\nconsole.log(var1, var2);\nb();\nconsole.log(var2);\n```",
        "options": {
            "A": "ReferenceError, ReferenceError",
            "B": "ReferenceError, 1",
            "C": "2, 3",
            "D": "1, 1"
        },
        "answer": "B",
        "explanation": "`var1` is block-scoped inside functions and not accessible outside. `var2 = 1` without var/let/const creates a global variable, so `var2` logs 1; `var1` is undefined outside, causing ReferenceError."
    },
    {
        "id": 146,
        "category": "nullish coalescing",
        "difficulty": "Medium",
        "question": "What is the difference between using `||` and `??` in this function?\n\n```js\nfunction showMessage(marks) {\n  const message = marks || \"Absent\";\n  console.log(`marks ${message}`);\n}\n\nshowMessage(44);\nshowMessage(0);\nshowMessage(60);\n```\n\nvs\n\n```js\nfunction showMessage(marks) {\n  const message = marks ?? \"Absent\";\n  console.log(`marks ${message}`);\n}\n\nshowMessage(44);\nshowMessage(0);\nshowMessage(60);\n```",
        "options": {
            "A": "`||` and `??` behave the same",
            "B": "`||` treats 0, '', false as falsy but `??` only checks for null or undefined",
            "C": "`??` treats all falsy values as absent",
            "D": "None of the above"
        },
        "answer": "B",
        "explanation": "`||` returns the right side if left side is any falsy value (0, '', false), while `??` returns the right side only if left side is null or undefined."
    },
    {
        "id": 147,
        "category": "currying",
        "difficulty": "Medium",
        "question": "What will this function invocation output?\n\n```js\nconst add = (x) => (y) => (z) => {\n  console.log(x, y, z);\n  console.log(x + y + z);\n};\n\nadd(10)(10)(10);\n\n// Equivalent traditional function\nfunction add(x) {\n  return function (y) {\n    return function (z) {\n      return x + y + z;\n    };\n  };\n}\n```",
        "options": {
            "A": "Logs 10 10 10 and 30",
            "B": "Throws error",
            "C": "Undefined",
            "D": "Logs nothing"
        },
        "answer": "A",
        "explanation": "This is a curried function logging its arguments and their sum."
    },
    {
        "id": 148,
        "category": "truthy falsy",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nlet bool1 = false;\nlet bool2 = new Boolean(false);\n\nif(bool1) {\n  console.log(\"First Block\");\n}\nif(bool2) {\n  console.log(\"Second Block\");\n}\n```",
        "options": {
            "A": "Logs both blocks",
            "B": "Logs only 'First Block'",
            "C": "Logs only 'Second Block'",
            "D": "Logs nothing"
        },
        "answer": "C",
        "explanation": "Primitive false is falsy and skips first block; `new Boolean(false)` is an object (truthy) and executes second block."
    },
    {
        "id": 149,
        "category": "localStorage",
        "difficulty": "Medium",
        "question": "Fix this bug when retrieving a boolean false from localStorage:\n\n```js\nlocalStorage.setItem(\"pass\", false);\nlet ispass = localStorage.getItem(\"pass\");\n\nif(ispass){\n  console.log(\"You passed\");\n} else {\n  console.log(\"You will pass\");\n}\n```",
        "options": {
            "A": "No fix needed",
            "B": "Use `ispass !== \"false\"` in condition",
            "C": "Use JSON.parse on ispass",
            "D": "Use Boolean(ispass)"
        },
        "answer": "B",
        "explanation": "localStorage stores all values as strings, so `false` is stored as \"false\" string which is truthy. Check `ispass !== \"false\"` to fix."
    },
    {
        "id": 150,
        "category": "coercion",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nlet randomkey = {name:\"neel\"};\nrandomkey = 23;\n\nif(!randomkey === String) {\n  console.log(\"It is not a string\");\n} else {\n  console.log(\"It is a string\");\n}\n```",
        "options": {
            "A": "\"It is not a string\"",
            "B": "\"It is a string\"",
            "C": "Error",
            "D": "No output"
        },
        "answer": "B",
        "explanation": "`!randomkey` evaluates to false because 23 is truthy. Then `false === String` is false, so the else block runs."
    },
    {
        "id": 151,
        "category": "truthy/falsy",
        "difficulty": "Easy",
        "question": "What will be the output?\n\n```js\nconst list = [1,2];\n\nif(list.indexOf(1)) {\n  console.log(\"We have 1\");\n} else {\n  console.log(\"Error\");\n}\n```",
        "options": {
            "A": "\"We have 1\"",
            "B": "\"Error\"",
            "C": "Error",
            "D": "No output"
        },
        "answer": "B",
        "explanation": "`indexOf(1)` returns 0, which is falsy in JS conditionals, so else block runs printing \"Error\"."
    },
    {
        "id": 152,
        "category": "loops",
        "difficulty": "Medium",
        "question": "What is a better way to optimize this loop?\n\n```js\nconst data = new Array(100);\n\nfor(let i = 0; i < data.length; i++) {\n  console.log(i);\n}\n```",
        "options": {
            "A": "No optimization needed",
            "B": "Store data.length in a variable before the loop",
            "C": "Use while loop instead",
            "D": "Use forEach instead"
        },
        "answer": "B",
        "explanation": "Accessing data.length every iteration is inefficient; storing it in a variable before the loop improves performance."
    },
    {
        "id": 153,
        "category": "loops",
        "difficulty": "Medium",
        "question": "Find the bug in this sum function:\n\n```js\nfunction sum(num) {\n  var result = 0;\n  for (var i = 0; i <= num.length; i++) {\n    result = result + num[i];\n  }\n  return result;\n}\n\nvar numbers = [1, 2, 3, 4];\nconsole.log(sum(numbers));\n```\n",
        "options": {
            "A": "No bug, works fine",
            "B": "Change `i <= num.length` to `i < num.length`",
            "C": "Initialize result to null",
            "D": "Use forEach instead of for loop"
        },
        "answer": "B",
        "explanation": "Loop iterates one time too many, causing `num[i]` to be undefined; use `i < num.length` to fix."
    },
    {
        "id": 154,
        "category": "spread",
        "difficulty": "Easy",
        "question": "What will be the output of this function call?\n\n```js\nfunction sum(x, y, z) {\n  return x + y + z;\n}\n\nconsole.log(sum(...[1, 2, 3]));\n```\n",
        "options": {
            "A": "6",
            "B": "NaN",
            "C": "Error",
            "D": "undefined"
        },
        "answer": "A",
        "explanation": "Spread operator `...` passes array elements as individual arguments to the function."
    },
    {
        "id": 155,
        "category": "find",
        "difficulty": "Easy",
        "question": "What does this code do?\n\n```js\nconst arr = [\n  {id: 1, name: \"Neel\"},\n  {id: 2, name: \"Ashok\"},\n  {id: 3, name: \"Samel\"}\n];\n\nconst res = arr.find(chk) || {};\n\nfunction chk(data) {\n  return data.id === 2;\n}\n\nconsole.log(res);\n```\n",
        "options": {
            "A": "Finds object with id 2 or returns empty object if not found",
            "B": "Always returns empty object",
            "C": "Throws error",
            "D": "Returns array"
        },
        "answer": "A",
        "explanation": "`find` returns the first matching element or undefined; the `|| {}` fallback ensures res is an object."
    },
    {
        "id": 156,
        "category": "Objects",
        "difficulty": "Easy",
        "question": "What will be logged?\n\n```js\nconst obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconsole.log(obj.hasOwnProperty(\"1\"));\nconsole.log(obj.hasOwnProperty(1));\n```",
        "options": {
            "A": "true true",
            "B": "false false",
            "C": "true false",
            "D": "false true"
        },
        "answer": "A",
        "explanation": "Object keys are always strings internally; so hasOwnProperty(\"1\") and hasOwnProperty(1) both check for key \"1\" and return true."
    },
    {
        "id": 157,
        "category": "Constructor Functions",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nfunction car() {\n  this.make = 'audi';\n  return { make: 'bmw' };\n}\nconst mycar = new car();\nconsole.log(mycar.make);\n```",
        "options": {
            "A": "audi",
            "B": "bmw",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "When a constructor function explicitly returns an object, that object is returned instead of `this`."
    },
    {
        "id": 158,
        "category": "Reference Types",
        "difficulty": "Easy",
        "question": "What will be logged?\n\n```js\nlet c = { greeting: \"Hey\" };\nlet d;\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n```",
        "options": {
            "A": "Hey",
            "B": "Hello",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Objects are assigned by reference; changing `c.greeting` affects `d.greeting` since both reference the same object."
    },
    {
        "id": 159,
        "category": "Arrow Functions",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nconst income = {\n  skills: 12,\n  monthly() {\n    return this.skills * 2;\n  },\n  yearly: () => this.skills * 2,\n};\n\nconsole.log(income.monthly());\nconsole.log(income.yearly());\n```",
        "options": {
            "A": "24 24",
            "B": "24 NaN",
            "C": "NaN 24",
            "D": "NaN NaN"
        },
        "answer": "B",
        "explanation": "`monthly` is a normal method, so `this` refers to `income`; arrow function `yearly` uses lexical `this` (global/window), so `this.skills` is undefined, resulting in NaN."
    },
    {
        "id": 160,
        "category": "Object Keys",
        "difficulty": "Medium",
        "question": "What will this output?\n\n```js\nconst A = {};\nconst B = { key: \"b\" };\nconst C = { key: \"c\" };\n\nA[B] = 123;\nA[C] = 456;\n\nconsole.log(A[B]);\n```",
        "options": {
            "A": "123",
            "B": "456",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Objects used as keys are converted to the string \"[object Object]\", so A[B] and A[C] refer to the same key; the second assignment overwrites the first."
    },
    {
        "id": 161,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What will be the output?\n\n```js\nlet data = [1, 2, 3].map(num => {\n  if (typeof num === 'number') return;\n  return num * 2;\n});\nconsole.log(data);\n```",
        "options": {
            "A": "[2, 4, 6]",
            "B": "[undefined, undefined, undefined]",
            "C": "[null, null, null]",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The `if` condition is always true, so `return` without value returns undefined for each element."
    },
    {
        "id": 162,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What will be the result of this map?\n\n```js\n[1, 2, 3].map(num => {\n  if (num > 0) return;\n  return num * 2;\n});\n```",
        "options": {
            "A": "[2, 4, 6]",
            "B": "[undefined, undefined, undefined]",
            "C": "[0, 2, 4]",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Since `num > 0` is true for all elements, the function returns `undefined` each time."
    },
    {
        "id": 163,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What will be logged?\n\n```js\nlet count = 0;\nlet num = [0, 1, 2, 3];\n\nnum.forEach(num => {\n  if (num) {\n    count = count + 1;\n  }\n});\nconsole.log(count);\n```",
        "options": {
            "A": "4",
            "B": "3",
            "C": "0",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Falsy value 0 is skipped, so count increments for 1, 2, 3."
    },
    {
        "id": 164,
        "category": "Closures",
        "difficulty": "Easy",
        "question": "What will this IIFE print?\n\n```js\n(function(x) {\n  return (function(y) {\n    console.log(x);\n  })(2);\n})(1);\n```",
        "options": {
            "A": "1",
            "B": "2",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "Inner function closes over outer `x` which is 1."
    },
    {
        "id": 165,
        "category": "Promise",
        "difficulty": "Medium",
        "question": "What will be logged here?\n\n```js\nfunction task() {\n  return new Promise((res) => {\n    res(\"data\");\n  });\n}\n\nconst result = task().then();\nconsole.log(result);\n```",
        "options": {
            "A": "Promise { <pending> }",
            "B": "Promise { 'data' }",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "`task()` returns a resolved promise; `then()` returns a new promise resolving to the same value."
    },
    {
        "id": 166,
        "category": "Promise",
        "difficulty": "Easy",
        "question": "What will be logged?\n\n```js\nconsole.log(1);\n\nnew Promise((res) => {\n  console.log(2);\n});\n\nconsole.log(3);\n```",
        "options": {
            "A": "1 3 2",
            "B": "1 2 3",
            "C": "2 1 3",
            "D": "3 1 2"
        },
        "answer": "B",
        "explanation": "Promise constructor executes callback immediately, so 2 logs before 3."
    },
    {
        "id": 167,
        "category": "Functions",
        "difficulty": "Easy",
        "question": "What happens here?\n\n```js\nconst anonymous = function test() {\n  console.log(\"Hii neel\");\n}\ntest();\n```",
        "options": {
            "A": "Logs 'Hii neel'",
            "B": "ReferenceError: test is not defined",
            "C": "Syntax error",
            "D": "No output"
        },
        "answer": "B",
        "explanation": "Named function expressions have their name scoped inside the function only, `test` is not defined in outer scope."
    },
    {
        "id": 168,
        "category": "Async/Await",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nasync function getData() {\n  return await Promise.resolve(\"Solved\");\n}\n\nconst data = getData();\nconsole.log(data);\n// data.then(res => console.log(res));\n```",
        "options": {
            "A": "Solved",
            "B": "Promise { <pending> }",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Async functions always return a Promise object."
    },
    {
        "id": 169,
        "category": "Async/Await",
        "difficulty": "Medium",
        "question": "What is the order of logs here?\n\n```js\nconsole.log(\"A\");\n(async function () {\n  let x = await 5;\n  console.log(\"C\");\n})();\nconsole.log(\"B\");\n```",
        "options": {
            "A": "A B C",
            "B": "A C B",
            "C": "C A B",
            "D": "B A C"
        },
        "answer": "A",
        "explanation": "`await` pauses the async function, so \"C\" logs after the synchronous logs \"A\" and \"B\"."
    },
    {
        "id": 170,
        "category": "Event Loop",
        "difficulty": "Hard",
        "question": "What is the order of output?\n\n```js\nsetTimeout(() => {\n  console.log(\"1\");\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log(\"2\");\n});\n\nqueueMicrotask(() => {\n  console.log(\"3\");\n});\n\nconsole.log(\"4\");\n```",
        "options": {
            "A": "4 1 2 3",
            "B": "4 3 2 1",
            "C": "1 2 3 4",
            "D": "3 2 1 4"
        },
        "answer": "B",
        "explanation": "Microtasks (queueMicrotask and Promise) run after main stack; setTimeout runs last."
    },
    {
        "id": 171,
        "category": "event loop",
        "difficulty": "Medium",
        "question": "What will happen here?\n\n```js\nsetTimeout(() => {\n  console.log(\"Neel samel\");\n}, Infinity);\n\nsetTimeout(() => {\n  console.log(\"Neel samel\");\n}, 2147483647);\n\nconsole.log(Math.pow(2, 32) / 2 - 1);\n```",
        "options": {
            "A": "Both messages will print immediately",
            "B": "Message with Infinity timeout won't print; 2147483647 is max delay",
            "C": "Both messages will print after delay",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "JavaScript max delay for setTimeout is 2147483647ms (~24.8 days). Infinity exceeds this, so that callback never fires."
    },
    {
        "id": 172,
        "category": "hoisting",
        "difficulty": "Hard",
        "question": "What will this log?\n\n```js\nlet x = [typeof x, typeof y];\nconsole.log(x);\n```",
        "options": {
            "A": "[\"undefined\", \"undefined\"]",
            "B": "Error: Cannot access 'x' before initialization",
            "C": "[\"object\", \"undefined\"]",
            "D": "[]"
        },
        "answer": "B",
        "explanation": "`x` is accessed before initialization due to right-to-left evaluation and `let` hoisting rules."
    },
    {
        "id": 173,
        "category": "hoisting",
        "difficulty": "Easy",
        "question": "What will be printed?\n\n```js\nconsole.log(a);\nvar a;\n```",
        "options": {
            "A": "undefined",
            "B": "ReferenceError",
            "C": "null",
            "D": "Throws syntax error"
        },
        "answer": "A",
        "explanation": "`var` declarations are hoisted and initialized with `undefined` before execution."
    },
    {
        "id": 174,
        "category": "event loop",
        "difficulty": "Easy",
        "question": "What will the output be?\n\n```js\nconst a = () => console.log(\"neel\");\nconst b = () => setTimeout(() => { console.log(\"last\"); });\nconst c = () => console.log(\"neha\");\na();\nb();\nc();\n```",
        "options": {
            "A": "neel neha last",
            "B": "last neel neha",
            "C": "neha neel last",
            "D": "neel last neha"
        },
        "answer": "A",
        "explanation": "setTimeout callback runs after the current call stack, so 'last' prints last."
    },
    {
        "id": 175,
        "category": "strict mode",
        "difficulty": "Medium",
        "question": "What will happen when running this?\n\n```js\nfunction getage() {\n  'use strict';\n  age: 23;\n  console.log(age);\n}\ngetage();\n```",
        "options": {
            "A": "Logs 23",
            "B": "ReferenceError: age is not defined",
            "C": "Syntax Error",
            "D": "Logs undefined"
        },
        "answer": "B",
        "explanation": "Label syntax (`age: 23`) does not create a variable; 'age' is undefined in strict mode."
    },
    {
        "id": 176,
        "category": "event loop",
        "difficulty": "Medium",
        "question": "What will this code print?\n\n```js\nfor(var x = 0; x < 3; x++) {\n  setTimeout(() => console.log(x));\n}\n```",
        "options": {
            "A": "0 1 2",
            "B": "3 3 3",
            "C": "0 0 0",
            "D": "Undefined"
        },
        "answer": "B",
        "explanation": "`var` has function scope; the logged value is `3` when callbacks execute."
    },
    {
        "id": 177,
        "category": "event loop",
        "difficulty": "Easy",
        "question": "What will this log?\n\n```js\nlet a = \"Neel\";\nsetTimeout(() => {\n  console.warn(a);\n}, 0);\na = \"neha\";\n```",
        "options": {
            "A": "Neel",
            "B": "neha",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The timeout callback runs after synchronous code; `a` is updated before logging."
    },
    {
        "id": 178,
        "category": "hoisting",
        "difficulty": "Medium",
        "question": "What will this function print?\n\n```js\nfunction fruits() {\n  console.log(a);\n  console.log(b);\n\n  var a = \"apple\";\n  let b = \"orange\";\n}\nfruits();\n```",
        "options": {
            "A": "undefined 'orange'",
            "B": "'apple' 'orange'",
            "C": "undefined ReferenceError",
            "D": "ReferenceError ReferenceError"
        },
        "answer": "C",
        "explanation": "`var a` is hoisted and initialized as undefined, but `let b` is not accessible before declaration causing ReferenceError."
    },
    {
        "id": 179,
        "category": "temporal dead zone",
        "difficulty": "Medium",
        "question": "What will happen here?\n\n```js\nlet name = \"neel\";\nfunction chK() {\n  console.log(name);\n  let name = \"neha\";\n}\nchK();\n```",
        "options": {
            "A": "neel",
            "B": "neha",
            "C": "ReferenceError: Cannot access 'name' before initialization",
            "D": "undefined"
        },
        "answer": "C",
        "explanation": "Variable `name` inside function shadows outer one; `let` cannot be accessed before declaration."
    },
    {
        "id": 180,
        "category": "JavaScript",
        "difficulty": "Medium",
        "question": "What will be logged?\n\n```js\nconst bird = { name: \"Sparrow\" };\nconst animal = { name: \"Lion\" };\nfunction show() { console.log(this.name); }\nconst objshow = show.bind(bird);\nobjshow.call(animal);\n```\n",
        "options": {
            "A": "\"Lion\"",
            "B": "\"Sparrow\"",
            "C": "undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "Once a function is bound with `.bind()`, the `this` context is fixed to the bound object and cannot be changed by `.call()`."
    },
    {
        "id": 181,
        "category": "Functions and This",
        "difficulty": "Easy",
        "question": "What will be the output?\n\n```js\nconst person = { name: \"neel\" };\nfunction detail() { return this.name; }\nconsole.log(detail.call(person));\nconsole.log(detail.bind(person));\n```",
        "options": {
            "A": "\"neel\" and function definition",
            "B": "undefined and \"neel\"",
            "C": "\"neel\" and undefined",
            "D": "Error and function definition"
        },
        "answer": "A",
        "explanation": "`call()` invokes the function immediately with `this` set to `person`, returning 'neel'. `bind()` returns a new function bound to `person` but does not invoke it."
    },
    {
        "id": 182,
        "category": "Functions and This",
        "difficulty": "Medium",
        "question": "What will happen when calling this function?\n\n```js\nconst person = {\n  lang: \"Js\",\n  show: function () { console.log(`Language ${this.lang}`); }\n};\nconst fn = person.show;\nfn();\n```",
        "options": {
            "A": "Logs 'Language Js'",
            "B": "Logs 'Language undefined'",
            "C": "Throws an error",
            "D": "Nothing prints"
        },
        "answer": "B",
        "explanation": "Calling `fn()` without binding loses the object context, so `this.lang` is undefined."
    },
    {
        "id": 183,
        "category": "Functions and This",
        "difficulty": "Easy",
        "question": "What does this output?\n\n```js\nfunction test() {\n  console.log(typeof this);\n}\ntest.call();\n```",
        "options": {
            "A": "\"undefined\"",
            "B": "\"object\"",
            "C": "\"function\"",
            "D": "Throws error"
        },
        "answer": "B",
        "explanation": "In non-strict mode, `this` defaults to the global object which is of type \"object\"."
    },
    {
        "id": 184,
        "category": "Functions and This",
        "difficulty": "Easy",
        "question": "What is logged here?\n\n```js\nvar person = {\n  name: \"Neel\",\n  age: 25,\n  getage: function () { return this.age; }\n};\nvar person2 = { age: 25 };\nconsole.log(person.getage.call(person2));\n```",
        "options": {
            "A": "25",
            "B": "undefined",
            "C": "Error",
            "D": "null"
        },
        "answer": "A",
        "explanation": "`call()` sets `this` to `person2`, so `this.age` returns 25."
    },
    {
        "id": 185,
        "category": "proxy",
        "difficulty": "Medium",
        "question": "What happens with this Proxy example?\n\n```js\nconst handler = {\n  set: (target, property, value) =>\n    console.log(\"Add new Property\", target, property, value),\n  get: (target, property) =>\n    console.log(\"Access new Property\", target, property),\n};\nconst person = new Proxy({}, handler);\nperson.name = \"Neel\";\nperson.name;\n```",
        "options": {
            "A": "Logs messages on property add and access",
            "B": "Throws error due to handler misuse",
            "C": "Does nothing",
            "D": "Only logs when setting properties"
        },
        "answer": "A",
        "explanation": "Proxy intercepts property access and setting, logging both."
    },
    {
        "id": 186,
        "category": "function-call",
        "difficulty": "Medium",
        "question": "Which of these calls the function without parentheses?\n\n```js\nconst obj = {\n  show: function () { console.log(\"Neel Samel\"); },\n};\n\n// Which of these is valid?\n// 1) obj.show``\n// 2) new obj.show\n// 3) Using getter function get show() {}\n```",
        "options": {
            "A": "Only 1",
            "B": "Only 2",
            "C": "1 and 2",
            "D": "All 1, 2, and 3"
        },
        "answer": "D",
        "explanation": "Tagged template literals (obj.show``), `new` operator (new obj.show), and getter methods allow calling without parentheses."
    },
    {
        "id": 187,
        "category": "this-binding",
        "difficulty": "Easy",
        "question": "What does this log?\n\n```js\nvar person = {\n  name: \"Neel\",\n  age: 25,\n  getage: function () { return this.age; }\n};\nconsole.log(person.getage.call(this));\n```",
        "options": {
            "A": "25",
            "B": "undefined",
            "C": "Throws error",
            "D": "null"
        },
        "answer": "B",
        "explanation": "`this` in global context refers to the global object which likely has no `age` property, so undefined."
    },
    {
        "id": 188,
        "category": "set-object",
        "difficulty": "Medium",
        "question": "What will be the output?\n\n```js\nconst obj = {};\nconst set1 = new Set();\nconst set2 = new Set();\n\nset1.add(obj);\nset1.add(obj);\n\nset2.add({});\nset2.add({});\n\nconsole.log(set1.size);\nconsole.log(set2.size);\n```",
        "options": {
            "A": "1 and 2",
            "B": "2 and 2",
            "C": "1 and 1",
            "D": "2 and 1"
        },
        "answer": "A",
        "explanation": "Adding the same object reference twice counts once; adding two different objects counts twice."
    },
    {
        "id": 189,
        "category": "semantic-tags",
        "difficulty": "Easy",
        "question": "Which of the following tags is considered a semantic HTML tag?",
        "options": {
            "A": "<div>",
            "B": "<span>",
            "C": "<article>",
            "D": "<b>"
        },
        "answer": "C",
        "explanation": "Semantic HTML tags clearly describe their meaning in a human- and machine-readable way. `<article>` is semantic, whereas `<div>`, `<span>`, and `<b>` are not inherently semantic."
    },
    {
        "id": 190,
        "category": "structure-tags",
        "difficulty": "Easy",
        "question": "What is the main benefit of using the <header> and <footer> tags in HTML?",
        "options": {
            "A": "To create visual effects",
            "B": "To add images and links",
            "C": "To semantically mark up content, improving SEO and accessibility",
            "D": "To style the page background"
        },
        "answer": "C",
        "explanation": "The <header> and <footer> tags are semantic HTML elements that help structure content meaningfully. They improve SEO, accessibility, and overall document structure without adding styling or effects on their own."
    },
    {
        "id": 191,
        "category": "callback",
        "difficulty": "Easy",
        "question": "What is a callback function in JavaScript?",
        "options": {
            "A": "A function that is called when an event occurs.",
            "B": "A function that is passed as an argument to another function to be executed later.",
            "C": "A function that calls another function.",
            "D": "A function that returns another function."
        },
        "answer": "B",
        "explanation": "A callback function is a function passed as an argument to another function, which is then executed at a later time, often after a certain operation or event has occurred."
    },
    {
        "id": 192,
        "category": "responsive-design",
        "difficulty": "Easy",
        "question": "Which of the following <meta> tags is essential for making a webpage responsive?",
        "options": {
            "A": "<meta charset=\"UTF-8\">",
            "B": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
            "C": "<meta name=\"keywords\" content=\"HTML, SEO\">",
            "D": "<meta name=\"author\" content=\"John Doe\">"
        },
        "answer": "B",
        "explanation": "The viewport meta tag is crucial for responsive web design as it instructs the browser to adjust the page's width and scaling based on the device screen size."
    },
    {
        "id": 193,
        "category": "form",
        "difficulty": "Easy",
        "question": "Identify the error in the following form input for a password:\n\n<input type=\"pass\" id=\"password\" name=\"password\">",
        "options": {
            "A": "The type attribute should be password",
            "B": "The id attribute is incorrect",
            "C": "The name attribute is missing",
            "D": "The input tag requires a maxlength attribute"
        },
        "answer": "A",
        "explanation": "The correct input type for password fields in HTML is `type=\"password\"`. The given code uses `type=\"pass\"`, which is invalid and will default to a text input field."
    },
    {
        "id": 194,
        "category": "anchor-tag",
        "difficulty": "Medium",
        "question": "What is wrong with the following link element?\n\n<a href=\"https://www.example.com\">Example Site</a>",
        "options": {
            "A": "The target attribute is missing for opening the link in a new tab",
            "B": "The href attribute should be link",
            "C": "The text should be inside a <p> tag",
            "D": "The alt attribute is missing"
        },
        "answer": "A",
        "explanation": "There is nothing inherently wrong with this link. However, if the intention is to open it in a new tab, the attribute `target=\"_blank\"` should be added. The `alt` attribute is only used for images, not links."
    },
    {
        "id": 195,
        "category": "list",
        "difficulty": "Easy",
        "question": "Find the error in the following unordered list:\n\n<ul>\n  <li>Item 1\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>",
        "options": {
            "A": "<ul> should be <ol>",
            "B": "<li> should be <ul>",
            "C": "The first <li> tag is not closed",
            "D": "The ul tag requires a type attribute"
        },
        "answer": "C",
        "explanation": "In an unordered list, each <li> element must have both opening and closing tags. The first <li> element 'Item 1' is missing its closing </li> tag."
    },
    {
        "id": 196,
        "category": "Events",
        "difficulty": "Easy",
        "question": "What will be the output of the following HTML and JavaScript code?\n\n<button onclick=\"console.log('Button clicked')\">Press Me</button>",
        "options": {
            "A": "An alert saying 'Button clicked' appears.",
            "B": "The message 'Button clicked' is logged in the console.",
            "C": "Nothing happens.",
            "D": "The button does not display."
        },
        "answer": "B",
        "explanation": "The `onclick` event handler executes the JavaScript `console.log('Button clicked')` when the button is pressed, printing the message in the browser's console."
    },
    {
        "id": 197,
        "category": "Loops",
        "difficulty": "Easy",
        "question": "Which of the following is the correct syntax for a while loop in JavaScript?",
        "options": {
            "A": "while(condition) { //code }",
            "B": "while(condition); { //code }",
            "C": "while ( condition //code }",
            "D": "while (condition) { } else { //code }"
        },
        "answer": "A",
        "explanation": "The correct syntax for a while loop in JavaScript is `while(condition) { //code }`. The loop runs repeatedly as long as the specified condition evaluates to true."
    },
    {
        "id": 198,
        "category": "HTML",
        "difficulty": "Easy",
        "question": "What will the following HTML code display?\n\n<ol>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ol>",
        "options": {
            "A": "A bulleted list",
            "B": "A list with numbered items 1, 2, 3",
            "C": "A list with letters A, B, C",
            "D": "A list with Roman numerals I, II, III"
        },
        "answer": "B",
        "explanation": "An ordered list (<ol>) in HTML displays list items with numbers (1, 2, 3) by default unless a different list-style-type is specified."
    },
    {
        "id": 199,
        "category": "CSS",
        "difficulty": "Easy",
        "question": "Which display property makes an element behave like a block element while allowing inline content on the same line?",
        "options": {
            "A": "inline",
            "B": "block",
            "C": "inline-block",
            "D": "none"
        },
        "answer": "C",
        "explanation": "The `inline-block` display property makes an element behave like a block element (accepting width and height) while still allowing inline content to sit beside it on the same line."
    },
    {
        "id": 200,
        "category": "CSS",
        "difficulty": "Easy",
        "question": "The following code causes overlapping elements. How can you fix this?\n\n.container {\n    position: absolute;\n    left: 0;\n}\n\n.box {\n    position: relative;\n    top: -50px;\n}",
        "options": {
            "A": "Add z-index to .box",
            "B": "Change .container to position: relative",
            "C": "Add padding to .container",
            "D": "Use display: inline for .box"
        },
        "answer": "B",
        "explanation": "Changing `.container` to `position: relative` establishes a new containing block for absolutely or relatively positioned child elements like `.box`, preventing unintended overlapping."
    },
    {
        "id": 201,
        "category": "Inheritance & Specificity",
        "difficulty": "Easy",
        "question": "Why does the following paragraph not inherit the font color of its parent <div>?",
        "options": {
            "A": "The initial value overrides inheritance.",
            "B": "Font color is not an inheritable property.",
            "C": "The p tag has a higher specificity.",
            "D": "The <div> needs !important to pass color"
        },
        "answer": "C",
        "explanation": "In CSS, specificity can override inheritance. If a paragraph has its own style rule with higher specificity (e.g., inline styles or more targeted selectors), it will override the inherited styles from its parent unless `!important` is used."
    },
    {
        "id": 202,
        "category": "Box Model & Overflow",
        "difficulty": "Easy",
        "question": "The following CSS is applied, but the margin of .box is not affecting the container. What is the likely issue?\n\n.container {\n    overflow: hidden;\n}\n\n.box {\n    margin-top: 20px;\n}",
        "options": {
            "A": "Use overflow: visible.",
            "B": "Add padding to .container.",
            "C": "Add padding to .container.",
            "D": "Remove overflow from .container"
        },
        "answer": "D",
        "explanation": "When `overflow: hidden` is applied to a container, it can cause margin collapse issues, where the top margin of a child element doesnâ€™t affect the containerâ€™s height. Removing or adjusting the overflow property can resolve this."
    },
    {
        "id": 203,
        "category": "Positioning",
        "difficulty": "Easy",
        "question": "Why does the sticky positioning in the following example not work?\n\n.sticky-box {\n    position: sticky;\n    top: 0;\n}",
        "options": {
            "A": "Sticky positioning requires overflow: auto on the parent",
            "B": "The parent containerâ€™s height is not specified.",
            "C": "The top property should be set to a percentage",
            "D": "The sticky-box needs to be a flex child."
        },
        "answer": "A",
        "explanation": "For `position: sticky` to work, the parent container should not have `overflow: hidden`, `scroll`, or similar values. Ideally, it should have `overflow: auto` or `visible`, otherwise sticky elements may not behave as expected."
    },
    {
        "id": 204,
        "category": "Display & Layout",
        "difficulty": "Easy",
        "question": "Why are the inline boxes in the following layout not aligning perfectly horizontally when using display: inline-block?",
        "options": {
            "A": "The parent container needs display: flex.",
            "B": "The elements need float: left instead of inline-block.",
            "C": "The inline-boxes should be positioned relative.",
            "D": "There is whitespace between the inline-boxes in HTML."
        },
        "answer": "D",
        "explanation": "When using display: inline-block, whitespace characters (like spaces or newlines) between elements in HTML are rendered as actual space in the layout. Removing this whitespace fixes the alignment issue."
    },
    {
        "id": 205,
        "category": "Positioning",
        "difficulty": "Easy",
        "question": "What is the default position property of HTML elements?",
        "options": {
            "A": "Relative",
            "B": "Fixed",
            "C": "Absolute",
            "D": "Static"
        },
        "answer": "D",
        "explanation": "By default, all HTML elements have `position: static`, meaning they follow the normal document flow. This positioning does not allow the use of offset properties like top, bottom, left, or right."
    },
    {
        "id": 206,
        "category": "CSS",
        "difficulty": "Easy",
        "question": "Which component of the CSS Box Model adds space between the content and the border of an element?",
        "options": {
            "A": "Content",
            "B": "Padding",
            "C": "Margin",
            "D": "Border"
        },
        "answer": "B",
        "explanation": "Padding adds space between the content and the border of an element in the CSS Box Model."
    },
    {
        "id": 207,
        "category": "CSS",
        "difficulty": "Easy",
        "question": "What will be the output of this HTML and CSS?",
        "code": ".box {\n  display: none;\n}",
        "options": {
            "A": "The text is visible but without borders.",
            "B": "The text is hidden but still occupies space.",
            "C": "The text is hidden and takes no space.",
            "D": "Throws an error due to display: none"
        },
        "answer": "C",
        "explanation": "When `display: none` is applied to an element, it is completely removed from the document flow and takes up no space in the layout."
    },
    {
        "id": 208,
        "category": "Execution Context",
        "difficulty": "Easy",
        "question": "Which of the following statements best describes the global execution context?",
        "code": "",
        "options": {
            "A": "It only contains local variables and functions.",
            "B": "It contains the global object and is created when the script starts.",
            "C": "It is created every time a function is called.",
            "D": "It is used only inside block scopes."
        },
        "answer": "B",
        "explanation": "The global execution context is created when the script starts and includes the global object and any variables or functions declared in the global scope."
    },
    {
        "id": 209,
        "category": "Execution Context",
        "difficulty": "Easy",
        "question": "What is the correct order of how the call stack handles function execution?",
        "code": "",
        "options": {
            "A": "First In, First Out (FIFO)",
            "B": "Last In, Last Out (LILO)",
            "C": "First In, Last Out (FILO)",
            "D": "Last In, First Out (LIFO)"
        },
        "answer": "D",
        "explanation": "The call stack uses the Last In, First Out (LIFO) principle. The last function pushed onto the stack is the first to be popped off and executed."
    },
    {
        "id": 210,
        "category": "Scope",
        "difficulty": "Easy",
        "question": "What does the scope chain allow?",
        "code": "",
        "options": {
            "A": "The creation of local variables within a function.",
            "B": "The definition of functions within another function.",
            "C": "Resolving variables by checking outer environments if not found locally.",
            "D": "Avoiding hoisting of variables."
        },
        "answer": "C",
        "explanation": "The scope chain allows the interpreter to resolve variables by looking up through outer lexical environments when a variable is not found in the current scope."
    },
    {
        "id": 211,
        "category": "Hoisting",
        "difficulty": "Easy",
        "question": "Find the error in the following code:",
        "code": "function sayHello() {\n  console.log(message);\n  var message = \"Hello!\";\n}\nsayHello();",
        "options": {
            "A": "message should be a global variable.",
            "B": "The variable message is not hoisted properly.",
            "C": "The variable message is not initialized before console.log.",
            "D": "The function sayHello cannot be called like this."
        },
        "answer": "C",
        "explanation": "Although `var` is hoisted, only its declaration is hoisted, not its initialization. So `console.log(message)` runs before `message = \"Hello!\"`, and prints `undefined` because the variable exists but hasnâ€™t been assigned a value yet."
    },
    {
        "id": 212,
        "category": "Recursion & Stack",
        "difficulty": "Easy",
        "question": "Identify the issue in the following code causing stack overflow:",
        "code": "function repeat() {\n  repeat();\n}\nrepeat();",
        "options": {
            "A": "Infinite recursion (fn calling itself) with no base case (stopping condtn.) causes a stack overflow.",
            "B": "Function repeat is improperly declared.",
            "C": "The repeat function is not called properly.",
            "D": "The repeat function is not called properly. It is not possible to call a function recursively in JavaScript."
        },
        "answer": "A",
        "explanation": "The function `repeat()` calls itself recursively without a base condition, leading to infinite recursion and eventually a stack overflow error in JavaScript."
    },
    {
        "id": 213,
        "category": "Hoisting & Temporal Dead Zone",
        "difficulty": "Easy",
        "question": "Which of the following will prevent a ReferenceError due to hoisting?",
        "code": "console.log(myVar);\nlet myVar = \"Not hoisted\";",
        "options": {
            "A": "Changing let to var",
            "B": "Declaring myVar before logging it",
            "C": "Using const instead of let",
            "D": "Wrapping the code in a function"
        },
        "answer": "B",
        "explanation": "In JavaScript, variables declared with `let` are not hoisted to the top in the same way as `var`. Accessing them before declaration results in a ReferenceError. Declaring `myVar` before logging it avoids this issue."
    },
    {
        "id": 214,
        "category": "Hoisting",
        "difficulty": "Easy",
        "question": "Which of the following statements is true regarding hoisting in JavaScript?",
        "options": {
            "A": "Variables declared with let are fully hoisted and initialized to undefined.",
            "B": "Variables declared with var are partially hoisted and initialized to undefined.",
            "C": "Functions are never hoisted in JavaScript.",
            "D": "const variables are hoisted but initialized to null."
        },
        "answer": "B",
        "explanation": "Variables declared with `var` are hoisted to the top of their scope and initialized with `undefined`. In contrast, `let` and `const` are hoisted but not initialized, which causes a ReferenceError if accessed before declaration."
    },
    {
        "id": 215,
        "category": "Recursion & Stack",
        "difficulty": "Easy",
        "question": "Which of the following code snippets will lead to a stack overflow?",
        "code": "function factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1);\n}\nconsole.log(factorial(5));",
        "options": {
            "A": "Yes, it will cause stack overflow.",
            "B": "No, the recursion (fn calling itself) terminates correctly.",
            "C": "It will cause a ReferenceError.",
            "D": "The function factorial should return undefined."
        },
        "answer": "B",
        "explanation": "The recursion in this code has a valid base case (`if (n === 1) return 1;`), so it terminates correctly and computes the factorial of 5 without causing a stack overflow."
    },
    {
        "id": 216,
        "category": "Lexical Scope",
        "difficulty": "Easy",
        "question": "What will the following code output?",
        "code": "let greeting = \"Hi\";\n\nfunction outer() {\n    let greeting = \"Hello\";\n    function inner() {\n        console.log(greeting);\n    }\n    inner();\n}\n\nouter();",
        "options": {
            "A": "Hi",
            "B": "Hello",
            "C": "undefined",
            "D": "ReferenceError"
        },
        "answer": "B",
        "explanation": "The `inner` function has access to its outer function's scope. Since `outer` declares `greeting` as 'Hello', this value is used by `inner()`."
    },
    {
        "id": 217,
        "category": "Execution Context & Scope",
        "difficulty": "Easy",
        "question": "Which of the following is true regarding the variable environment in function execution contexts?",
        "options": {
            "A": "Local variables are stored in the global execution context.",
            "B": "Each function execution context has its own variable environment.",
            "C": "Local variables are accessible globally.",
            "D": "The global variable environment stores function parameters."
        },
        "answer": "B",
        "explanation": "Each function execution context in JavaScript maintains its own variable environment for local variables and parameters, separate from the global or other function contexts."
    },
    {
        "id": 218,
        "category": "Closures",
        "difficulty": "Easy",
        "question": "What is a closure in JavaScript?",
        "options": {
            "A": "A function that does not use global variables.",
            "B": "A function bundled with its lexical environment, retaining access to the scope where it was created.",
            "C": "A function that is called immediately after it is defined.",
            "D": "A function that cleans up memory after execution."
        },
        "answer": "B",
        "explanation": "A closure is a function combined with its lexical environment. It allows the function to access variables from the scope in which it was defined, even after that scope has closed."
    },
    {
        "id": 219,
        "category": "Closures",
        "difficulty": "Easy",
        "question": "Which of the following is NOT a key characteristic of closures?",
        "options": {
            "A": "Preserving access to variables after the outer function has finished.",
            "B": "Enabling data privacy through encapsulation.",
            "C": "Destroying the access to variables after the outer function has finished.",
            "D": "Allowing functions to retain state across multiple invocations"
        },
        "answer": "C",
        "explanation": "Closures preserve access to variables even after the outer function has finished. They do not destroy access â€” this is what makes closures powerful for data encapsulation and maintaining state."
    },
    {
        "id": 220,
        "category": "Closures",
        "difficulty": "Easy",
        "question": "What will be the output of the following code?\n\n```js\nfunction outer() {\n  let message = \"Hello\";\n  return function inner() {\n    return message + \" World\";\n  };\n}\nconst closure = outer();\nconsole.log(closure());\n```",
        "options": {
            "A": "Hello",
            "B": "World",
            "C": "Hello World",
            "D": "Undefined"
        },
        "answer": "C",
        "explanation": "The function `inner` forms a closure over `message`, which is defined in `outer`. Even after `outer` has returned, `inner` retains access to `message`, so calling `closure()` returns `Hello World`."
    },
    {
        "id": 221,
        "category": "Closures & Scope",
        "difficulty": "Easy",
        "question": "Find the error in the following closure and suggest a fix:\n\n```js\nfunction counter() {\n  let count = 0;\n  return function() {\n    console.log(count++);\n  }\n}\nconst c = counter();\nc();\nc();\nconsole.log(count);\n```",
        "options": {
            "A": "count should be initialized outside the function.",
            "B": "counter() should return a function that resets the count each time.",
            "C": "count is not accessible outside the closure.",
            "D": "count should be declared with var instead of let."
        },
        "answer": "C",
        "explanation": "The variable `count` is declared inside `counter()` and is only accessible within the returned function. Trying to access it outside, like in `console.log(count);`, results in a ReferenceError because it's not in the global scope."
    },
    {
        "id": 222,
        "category": "Closures & IIFE",
        "difficulty": "Easy",
        "question": "What will be the output of this code?\n\n```js\nlet counter = (function () {\n  let count = 0;\n  return function () {\n    count++;\n    console.log(count);\n  };\n})();\n\ncounter();\ncounter();\ncounter();\n```",
        "options": {
            "A": "0 1 2",
            "B": "1 2 3",
            "C": "Undefined",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The IIFE (Immediately Invoked Function Expression) creates a closure over the `count` variable. Each call to `counter()` increases `count`, which is preserved across invocations, so the output is `1 2 3`."
    },
    {
        "id": 223,
        "category": "Hoisting & Temporal Dead Zone",
        "difficulty": "Easy",
        "question": "Which of the following will prevent a ReferenceError due to hoisting?\n\n```js\nconsole.log(myVar);\nlet myVar = \"Not hoisted\";\n```",
        "options": {
            "A": "Changing let to var",
            "B": "Declaring myVar before logging it",
            "C": "Using const instead of let",
            "D": "Wrapping the code in a function"
        },
        "answer": "B",
        "explanation": "Using `let` or `const` creates a temporal dead zone, and accessing the variable before declaration results in a ReferenceError. To avoid this, declare `myVar` before accessing it."
    },
    {
        "id": 224,
        "category": "Closures & Scope",
        "difficulty": "Medium",
        "question": "Identify the bug in the following code:\n\n```js\nfunction createLogger() {\n  var logs = [];\n  return function (log) {\n    logs.push(log);\n    console.log(logs);\n  }\n}\nconst logData = createLogger();\nlogData(\"Test\");\nlogData(\"Debug\");\nconsole.log(logs);\n```",
        "options": {
            "A": "logs should be declared outside the function.",
            "B": "logs is not accessible globally.",
            "C": "logs must be initialized with an empty string.",
            "D": "logs should be accessed using the return statement."
        },
        "answer": "B",
        "explanation": "`logs` is declared inside the `createLogger` function and is not accessible outside of it. Attempting to access `logs` globally results in a ReferenceError."
    },
    {
        "id": 225,
        "category": "Higher-Order Functions & Closures",
        "difficulty": "Easy",
        "question": "What will be the output of the following code?\n\n```js\nfunction multiply(x) {\n  return function(y) {\n    return x * y;\n  }\n}\nlet multiplyBy2 = multiply(2);\nconsole.log(multiplyBy2(5));\n```",
        "options": {
            "A": "2",
            "B": "5",
            "C": "10",
            "D": "NaN"
        },
        "answer": "C",
        "explanation": "`multiply` is a higher-order function returning another function. `multiplyBy2` becomes a function that multiplies its input by 2. So `multiplyBy2(5)` returns `2 * 5 = 10`."
    },
    {
        "id": 226,
        "category": "Higher-Order Functions & Closures",
        "difficulty": "Easy",
        "question": "What is a Higher-Order Function (HOF) in JavaScript?",
        "options": {
            "A": "A function that returns a string",
            "B": "A function that manipulates arrays",
            "C": "A function that takes or returns another function",
            "D": "A function that directly modifies objects"
        },
        "answer": "C",
        "explanation": "A Higher-Order Function in JavaScript is a function that takes another function as an argument or returns a function as its result."
    },
    {
        "id": 227,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What is the key difference between the map() and forEach() methods in JavaScript?",
        "options": {
            "A": "forEach() returns a new array, while map() does not",
            "B": "map() performs transformations and returns a new array, while forEach() is used for side effects and returns undefined",
            "C": "Both are identical in behavior",
            "D": "forEach() can be chained, but map() cannot"
        },
        "answer": "B",
        "explanation": "map() is used to create a new array by transforming elements, while forEach() simply executes a function for each element without returning a new array (returns undefined)."
    },
    {
        "id": 228,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What is the default behavior of the sort() method in JavaScript?",
        "options": {
            "A": "Sorts numbers in ascending order",
            "B": "Sorts strings based on Unicode values",
            "C": "Sorts objects by their properties",
            "D": "Sorts arrays randomly"
        },
        "answer": "B",
        "explanation": "By default, the sort() method in JavaScript converts elements to strings and sorts them based on their Unicode code point values."
    },
    {
        "id": 229,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "Find the error in the following map() code:\n\n```js\nconst numbers = [10, 20, 30];\nconst doubled = numbers.map(num => { num * 2; });\nconsole.log(doubled);\n```",
        "options": {
            "A": "map() should return an array, not undefined",
            "B": "The function should return num * 2 inside the callback",
            "C": "numbers needs to be a string array",
            "D": "map() cannot be used with numbers"
        },
        "answer": "B",
        "explanation": "In arrow functions with curly braces, you need to explicitly use the return statement. The correct code is:\n```js\nconst doubled = numbers.map(num => { return num * 2; });\n```"
    },
    {
        "id": 230,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "Identify the issue with the reduce() method usage below:\n\n```js\nconst sum = [1, 2, 3].reduce((acc, val) => acc + val);\nconsole.log(sum);\n```",
        "options": {
            "A": "reduce() requires a second argument, initialValue",
            "B": "reduce() should return an array",
            "C": "The callback function should be ((acc, val) => acc * val)",
            "D": "reduce() cannot be used on numbers"
        },
        "answer": "A",
        "explanation": "While reduce() can work without an initial value, it's best practice to always provide one. Omitting it may lead to errors with empty arrays. The correct usage is:\n```js\nconst sum = [1, 2, 3].reduce((acc, val) => acc + val, 0);\n```"
    },
    {
        "id": 231,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "Find the issue in this filter() function:\n\n```js\nconst evenNumbers = [1, 2, 3, 4].filter(function(num) {\n  num % 2 === 0;\n});\nconsole.log(evenNumbers);\n```",
        "options": {
            "A": "filter() does not work with numbers",
            "B": "filter() should return num % 2 === 0 in the callback",
            "C": "num % 2 will return a string",
            "D": "filter() cannot be chained"
        },
        "answer": "B",
        "explanation": "In the filter callback function, a return statement is required to specify the condition. The correct code is:\n```js\nconst evenNumbers = [1, 2, 3, 4].filter(function(num) {\n  return num % 2 === 0;\n});\n```"
    },
    {
        "id": 232,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What is the output of this code snippet?\n\n```js\nconst numbers = [1, 2, 3];\nconst total = numbers.reduce((acc, val) => acc + val, 0);\nconsole.log(total);\n```",
        "options": {
            "A": "3",
            "B": "6",
            "C": "0",
            "D": "9"
        },
        "answer": "B",
        "explanation": "The reduce() method sums all elements of the array starting from the initial value 0. Calculation: 0+1+2+3 = 6."
    },
    {
        "id": 233,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "Which of the following operations modifies the original array?",
        "options": {
            "A": "map()",
            "B": "filter()",
            "C": "reduce()",
            "D": "sort()"
        },
        "answer": "D",
        "explanation": "The `sort()` method modifies the original array by rearranging its elements in place. Other methods like `map()`, `filter()`, and `reduce()` return new arrays or values without altering the original array."
    },
    {
        "id": 234,
        "category": "Array Methods",
        "difficulty": "Medium",
        "question": "What will the output of the following chained methods be?\n\nconst values = [2, 3, 4];\nconst result = values.map(x => x + 1).reduce((a, b) => a * b);\nconsole.log(result);",
        "options": {
            "A": "48",
            "B": "36",
            "C": "60",
            "D": "12"
        },
        "answer": "C",
        "explanation": "The `map()` method adds 1 to each element, producing [3, 4, 5]. The `reduce()` method multiplies them: 3 * 4 * 5 = 60."
    },
    {
        "id": 235,
        "category": "Array Methods",
        "difficulty": "Easy",
        "question": "What is the output of the following code?\n\nconst result = [5, 10, 15].reduce((acc, val) => acc + val, 5);\nconsole.log(result);",
        "options": {
            "A": "20",
            "B": "25",
            "C": "30",
            "D": "35"
        },
        "answer": "D",
        "explanation": "The reduce function starts with the initial value 5 and adds each element: 5 + 5 = 10, 10 + 10 = 20, 20 + 15 = 35. So the final result is 35."
    },
    {
        "id": 236,
        "category": "JSON",
        "difficulty": "Easy",
        "question": "What is the purpose of the JSON.stringify() method in JavaScript?",
        "options": {
            "A": "It converts a JavaScript object to a JSON string.",
            "B": "It parses a JSON string into a JavaScript object.",
            "C": "It converts a JavaScript function to a JSON string.",
            "D": "It converts a JavaScript object into an array."
        },
        "answer": "A",
        "explanation": "JSON.stringify() is used to convert a JavaScript object into a JSON string. This is helpful when you need to store or send the object as text, such as when making API requests or using localStorage."
    },
    {
        "id": 237,
        "category": "this keyword",
        "difficulty": "Easy",
        "question": "Which of the following is true about the `this` keyword in JavaScript?",
        "options": {
            "A": "The value of this is always the global object.",
            "B": "The value of this is determined by the object that calls the function.",
            "C": "The value of this is always null.",
            "D": "The value of this can only be used in constructors."
        },
        "answer": "B",
        "explanation": "In JavaScript, the value of `this` depends on how a function is called. It refers to the object that is calling the function, unless in arrow functions or strict mode where behavior may differ. Hence, it is not always the global object."
    },
    {
        "id": 238,
        "category": "Function Methods",
        "difficulty": "Easy",
        "question": "What is the difference between the call() and apply() methods in JavaScript?",
        "options": {
            "A": "The call() method is used to invoke a function with a specified this context, while apply() invokes the function with an array of arguments.",
            "B": "The apply() method is used to invoke a function with a specified this context, while call() invokes the function with an array of arguments.",
            "C": "The call() and apply() methods are identical and can be used interchangeably.",
            "D": "The call() method allows passing the this context, but apply() does not."
        },
        "answer": "A",
        "explanation": "Both call() and apply() are used to invoke functions with a specified this value. The difference is in how arguments are passed: call() accepts a list of arguments, while apply() accepts a single array of arguments."
    },
    {
        "id": 239,
        "category": "Function Methods",
        "difficulty": "Easy",
        "question": "Which of the following methods allows you to bind a specific this context to a function for later execution?",
        "options": {
            "A": "bind()",
            "B": "apply()",
            "C": "call()",
            "D": "setTimeout()"
        },
        "answer": "A",
        "explanation": "The bind() method creates a new function with the specified this value, allowing you to bind a specific context to a function that can be executed later. Unlike call() and apply(), bind() does not execute the function immediately."
    },
    {
        "id": 240,
        "category": "Function Methods",
        "difficulty": "Easy",
        "question": "What will the following code output?",
        "code": "let person = { name: \"John\" };\nfunction greet() {\n    console.log(\"Hello, \" + this.name);\n}\nlet greetPerson = greet.bind(person);\ngreetPerson();",
        "options": {
            "A": "Hello, John",
            "B": "Hello, undefined",
            "C": "Hello, this.name",
            "D": "TypeError"
        },
        "answer": "A",
        "explanation": "The bind() method creates a new function with 'this' bound to the 'person' object. When greetPerson() is called, 'this.name' evaluates to 'John'."
    },
    {
        "id": 241,
        "category": "Promises",
        "difficulty": "Easy",
        "question": "Find the error in this Promise syntax:",
        "code": "let promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        reject(\"An error occurred\");\n    }, 1000);\n});\n\npromise.then((result) => {\n    console.log(result);\n});",
        "options": {
            "A": "reject should be resolve.",
            "B": "catch is needed to handle the error.",
            "C": "Promises cannot use setTimeout.",
            "D": "The code is correct."
        },
        "answer": "B",
        "explanation": "The code creates a rejected Promise, but the rejection is not being handled with a .catch() block. Without it, any rejection will go unhandled, possibly throwing an unhandled promise rejection warning or error."
    },
    {
        "id": 242,
        "category": "Promises",
        "difficulty": "Easy",
        "question": "What will happen with the following chain of promises if one promise rejects?",
        "code": "promise1\n  .then(() => promise2)\n  .then(() => promise3)\n  .then(() => console.log(\"All done\"))\n  .catch(() => console.log(\"Error caught\"));",
        "options": {
            "A": "It will skip to the next then regardless of rejection",
            "B": "It will only log \"All done\" if all promises are resolved",
            "C": "It will never execute the catch",
            "D": "It will log \"All done\" even if any promise is rejected"
        },
        "answer": "B",
        "explanation": "In a chain of promises, if any promise is rejected and not handled within a `.then()` block, the control moves to the `.catch()` block. Therefore, 'All done' is only logged if all promises are successfully resolved."
    },
    {
        "id": 243,
        "category": "Callbacks",
        "difficulty": "Easy",
        "question": "Identify the mistake in this code that fetches data with a callback:",
        "code": "function fetchData(callback) {\n    setTimeout(() => {\n        let data = \"Server data\";\n        callback;\n    }, 1000);\n}\n\nfetchData((data) => console.log(data));",
        "options": {
            "A": "callback should be invoked with parentheses",
            "B": "data is undefined",
            "C": "callback should not take parameter",
            "D": "setTimeout is unnecessary"
        },
        "answer": "A",
        "explanation": "In the code, `callback` is referenced but not invoked. It should be `callback(data)` to pass the data to the callback function. Without the parentheses, the callback is not executed."
    },
    {
        "id": 244,
        "category": "Asynchronous JavaScript",
        "difficulty": "Easy",
        "question": "What is the output of the following code?",
        "code": "console.log(\"Start\");\n\nsetTimeout(() => {\n    console.log(\"Task completed\");\n}, 1000);\n\nconsole.log(\"End\");",
        "options": {
            "A": "Start, Task completed, End",
            "B": "Start, End, Task completed",
            "C": "Task completed, Start, End",
            "D": "End, Task completed, Start"
        },
        "answer": "B",
        "explanation": "JavaScript is single-threaded and asynchronous operations (like setTimeout) are handled in the event loop. First, 'Start' is logged. Then 'End' is logged. After 1 second, 'Task completed' is logged. So the output order is: Start, End, Task completed."
    },
    {
        "id": 245,
        "category": "JavaScript Promises",
        "difficulty": "Easy",
        "question": "What is the output of this code snippet using promises?",
        "code": "let promise = new Promise((resolve) => {\n    resolve(\"Success!\");\n});\n\npromise\n    .then((result) => {\n        console.log(result);\n        return result;\n    })\n    .then((result) => {\n        console.log(result + \" Again\");\n    });",
        "options": {
            "A": "Success!",
            "B": "Success! Success!",
            "C": "Success! Success! Again",
            "D": "Success! Again"
        },
        "answer": "D",
        "explanation": "In the first `.then`, it logs `Success!` and returns that string. The second `.then` receives the returned value and logs `Success! Again`. So the final output is:\nSuccess!\nSuccess! Again"
    },
    {
        "id": 246,
        "category": "JavaScript Functions",
        "difficulty": "Easy",
        "question": "What is a primary benefit of using Factory Functions in JavaScript?",
        "options": {
            "A": "They enable the use of the new keyword to create objects.",
            "B": "They simplify object creation by encapsulating the object creation process within a function.",
            "C": "They make objects immutable.",
            "D": "They allow adding properties directly to the prototype of the function."
        },
        "answer": "B",
        "explanation": "Factory functions are functions that return objects. They encapsulate the object creation process, making it easier to manage and reuse. Unlike constructor functions, they don't require the `new` keyword and provide more flexibility in object creation patterns."
    },
    {
        "id": 247,
        "category": "JavaScript Functions",
        "difficulty": "Easy",
        "question": "Identify the error in the following code:",
        "code": "function car(make, model) {\n    this.make = make;\n    this.model = model;\n}\n\nlet myCar = car(\"Tesla\", \"Model S\");\nconsole.log(myCar.make);",
        "options": {
            "A": "myCar is not defined.",
            "B": "this is undefined in the function.",
            "C": "The new keyword is missing when creating myCar.",
            "D": "this should be myCar instead."
        },
        "answer": "C",
        "explanation": "The function `car` is intended to be used as a constructor, which requires the `new` keyword. Without `new`, `this` inside the function refers to the global object (or `undefined` in strict mode), and `myCar` will be `undefined`. Correct usage: `let myCar = new car(\"Tesla\", \"Model S\");`."
    },
    {
        "id": 248,
        "category": "JavaScript Objects",
        "difficulty": "Easy",
        "question": "What is the output of the following code snippet?",
        "code": "let person = {\n  birthYear: 1995,\n  getAge: function(currentYear) {\n    return currentYear - this.birthYear;\n  }\n};\n\nconsole.log(person.getAge(2024));",
        "options": {
            "A": "29",
            "B": "30",
            "C": "28",
            "D": "NaN"
        },
        "answer": "A",
        "explanation": "`person.birthYear` is 1995, and the function `getAge(2024)` returns `2024 - 1995 = 29`. Hence, the output is 29."
    },
    {
        "id": 249,
        "category": "JavaScript this/call",
        "difficulty": "Easy",
        "question": "What will be logged in the console?",
        "code": "let animal = {\n  legs: 4,\n  describe() {\n    console.log(`This animal has ${this.legs} legs.`);\n  }\n};\n\nlet fish = { legs: 0 };\nanimal.describe.call(fish);",
        "options": {
            "A": "This animal has 4 legs.",
            "B": "This animal has 0 legs.",
            "C": "Undefined legs.",
            "D": "This animal has 1 leg."
        },
        "answer": "B",
        "explanation": "The `call()` method sets the `this` value inside `describe()` to the `fish` object. Since `fish.legs` is `0`, the output is: 'This animal has 0 legs.'"
    },
    {
        "id": 250,
        "category": "JavaScript this/bind",
        "difficulty": "Easy",
        "question": "What is the result?",
        "code": "let dog = {\n  name: \"Buddy\",\n  sound: function() {\n    console.log(this.name + \" says woof!\");\n  }\n};\n\nlet soundFunc = dog.sound.bind({ name: \"Max\" });\nsoundFunc();",
        "options": {
            "A": "Buddy says woof!",
            "B": "Max says woof!",
            "C": "Undefined says woof!",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "`bind()` sets the `this` context permanently to the provided object. In this case, `{ name: \"Max\" }` is bound to the function, so `this.name` becomes `Max`. The output is: 'Max says woof!'"
    },
    {
        "id": 251,
        "category": "JavaScript Promises",
        "difficulty": "Easy",
        "question": "Find the error in this Promise syntax:",
        "code": "let promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\"An error occurred\");\n  }, 1000);\n});\n\npromise.then((result) => {\n  console.log(result);\n});",
        "options": {
            "A": "reject should be resolve.",
            "B": "catch is needed to handle the error.",
            "C": "Promises cannot use setTimeout.",
            "D": "The code is correct."
        },
        "answer": "B",
        "explanation": "The Promise rejects after 1 second, but there is no `.catch()` to handle the rejection. While the syntax is otherwise valid, the absence of a `.catch()` will result in an unhandled promise rejection."
    },
    {
        "id": 252,
        "category": "Promises",
        "difficulty": "Easy",
        "question": "What will happen with the following chain of promises if one promise rejects?",
        "code": "promise1\n  .then(() => promise2)\n  .then(() => promise3)\n  .then(() => console.log(\"All done\"))\n  .catch(() => console.log(\"Error caught\"));",
        "options": {
            "A": "It will skip to the next then regardless of rejection",
            "B": "It will only log \"All done\" if all promises are resolved",
            "C": "It will never execute the catch",
            "D": "It will log \"All done\" even if any promise is rejected"
        },
        "answer": "B",
        "explanation": "In a promise chain, if any promise rejects and the rejection is not handled before the `.then()` for \"All done\", the chain skips remaining `.then()` handlers and moves directly to the `.catch()` block."
    },
    {
        "id": 253,
        "category": "Callbacks",
        "difficulty": "Easy",
        "question": "Identify the mistake in this code that fetches data with a callback:",
        "code": "function fetchData(callback) {\n  setTimeout(() => {\n    let data = \"Server data\";\n    callback;\n  }, 1000);\n}\n\nfetchData((data) => console.log(data));",
        "options": {
            "A": "callback should be invoked with parentheses",
            "B": "data is undefined",
            "C": "callback should not take parameter",
            "D": "setTimeout is unnecessary"
        },
        "answer": "A",
        "explanation": "The callback is written as `callback;` which does nothing. It should be invoked using `callback(data);` to actually call the function and pass the `data`."
    },
    {
        "id": 254,
        "category": "Execution Order",
        "difficulty": "Easy",
        "question": "What is the output of the following code?",
        "code": "console.log(\"Start\");\n\nsetTimeout(() => {\n  console.log(\"Task completed\");\n}, 1000);\n\nconsole.log(\"End\");",
        "options": {
            "A": "Start, Task completed, End",
            "B": "Start, End, Task completed",
            "C": "Task completed, Start, End",
            "D": "End, Task completed, Start"
        },
        "answer": "B",
        "explanation": "JavaScript executes code synchronously by default. The `setTimeout` function schedules the callback to run after 1000 milliseconds, but the main thread continues executing the synchronous code. So, 'Start' is logged first, then 'End', and after about 1 second, 'Task completed' is logged."
    }
]